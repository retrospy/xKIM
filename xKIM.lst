AS65 Assembler for R6502 [1.42].                                     Page    1
---------------------------------- xKIM.asm ----------------------------------

2737 lines read, no errors in pass 1.
                        ;*****************************************************
                        ; Extended KIM monitor, written 2015 by Bob Applegate
                        ; K2UT - bob@corshamtech.com
                        ;
                        ; This code was written as part of the Corsham Tech
                        ; 60K RAM/EPROM board.  It provides a working area for
                        ; an extended version of the KIM-1 monitor capabilitie
                        ; mostly based on a TTY interface, not the keypad and
                        ; hex display.
                        ;
                        ; This extensions contains an assortment of basic
                        ; tools that are missing from the KIM-1's built in
                        ; console monitor.  It has commands for loading hex
                        ; files (as opposed to KIM format), accessing an SD
                        ; card system, memory edit, hex dump, etc.  It also
                        ; has the ability for user-defined extensions to be
                        ; added.  And a number of common entry points have
                        ; vectors so the monitor can be modified without
                        ; breaking programs that use it.
                        ;
                        ; I'm not claiming copyright; I wrote most of this,
                        ; but also borrowed from others (credit is given in
                        ; those sections of code).  All of the portions I've
                        ; written are free to use, but please keep my name
                        ; in the comments somewhere.  Even better, consider
                        ; buying a board from us: www.corshamtech.com
                        ;
                        ; 12/01/2015	Bob Applegate
                        ;		Initial development - V0.X
                        ; 03/15/2016	Bob Applegate
                        ;		v1.0 - First official release
                        ; 01/03/2017	Bob Applegate
                        ;		v1.1 - Added S command
                        ; 09/20/2018	Bob Applegate
                        ;		v1.2 - Added auto-run vector
                        ; 01/25/2019	Bob Applegate
                        ;		v1.3 - Added 'X' command.
                        ;		Added the 'C' command to get time.
                        ; 03/09/2019	Bob Applegate
                        ;		v1.4 - Added 'O' command.
                        ; 07/26/2020	Bob Applegate
                        ;		v1.5 - Fixed bug that caused the S
                        ;		command to create empty file with no
                        ;		contents.
                        ;		Minor typo fixes.
                        ;		Added CLD instructions.
                        ; 11/14/2020	Bob Applegate
                        ;		v1.6 - On SD error, display reason code.
                        ; 09/15/2021	Bob Applegate
                        ;		v1.7
                        ;		Added offset calculator command O.
                        ;		Added R command in Edit mode.
                        ;		Removed '.' when loading from console.
                        ; 09/20/2021	Bob Applegate
                        ;		v1.8
                        ;		Made a lot of the command handlers
                        ;		into subroutines and added vectors so
                        ;		external programs can call them.
                        ;		Fixed bugs in Edit mode.
                        ; 12/06/2023	Christopher 'Zoggins' Mallery
                        ;		v1.9
AS65 Assembler for R6502 [1.42].                                     Page    2
---------------------------------- xKIM.asm ----------------------------------

                        ;		Added IEC Save and Load commands
                        ;
                        ;*****************************************************
                        ;
                        ; Useful constants
                        ;
0000 =                  false		equ	0
ffff =                  true		equ	~false
                        ;
                        ; Version number
                        ;
0001 =                  VERSION		equ	1
0009 =                  REVISION	equ	9
0000 =                  BETA_VER	equ	0
                        ;
                        ; Options.  If RAM_BASED is set then the code is put
                        ; into RAM, else it's in ROM.  Very handy for testing
                        ; new code; load the new code with the EPROM version
                        ; and then test away.
                        ;
0000 =                  RAM_BASED	equ	false
af80 =                  RAM_DATA_BASE	equ	$af80
b000 =                  RAM_CODE_BASE	equ	$b000
                        ;
                        ; Set the EPROM base addresses
                        ;
e000 =                  ROM_START	equ	$e000
df80 =                  RAM_START	equ	$df80
                        ;
                        ; This is something that needs more investigation.
                        ; If the SD system isn't reset enough then bad stuff
                        ; happens after the RS button is pressed.  Set this to
                        ; true to only reset the SD system on cold starts.
                        ;
0000 =                  SD_ONLY_COLD	equ	false
                        ;
                        ; Set this to true to include Bob's Tiny BASIC.  It's
                        ; a minimal (ie, tiny) BASIC interpreter good for
                        ; playing around.
                        ;
0000 =                  TINY_BASIC	equ	false
                        ;
                        ; Set this to true to include a command to get/display
                        ; the current time from Corsham Tech SD card.
                        ;
ffff =                  SHOW_RTC	equ	true
                        ;
                        ; Non-printable ASCII constants
                        ;
0000 =                  NUL		equ	$00
0008 =                  BS		equ	$08
000a =                  LF		equ	$0a
000d =                  CR		equ	$0d
001b =                  ESC		equ	$1b
0020 =                  SPC		equ	$20
                        ;
                        ; Intel HEX record types
                        ;
0000 =                  DATA_RECORD	equ	$00
0001 =                  EOF_RECORD	equ	$01
                        ;
                        ; These are various buffer sizes
AS65 Assembler for R6502 [1.42].                                     Page    3
---------------------------------- xKIM.asm ----------------------------------

                        ;
000c =                  FILENAME_SIZE	equ	12
0040 =                  BUFFER_SIZE	equ	64
                        ;
                        ; Max number of bytes per line for hex dump
                        ;
0010 =                  BYTESLINE	equ	16
                        ;
                        ; Flag values used to detect a cold start vs warm
                        ;
0019 =                  COLD_FLAG_1	equ	$19
0062 =                  COLD_FLAG_2	equ	$62
                        ;
                        ; Flag value to detect we need to restore interrupt ve
                        ;
00ab =                  VEC_FLAG_1 equ $AB
00ab =                  VEC_FLAG_2 equ $AB
                        ;
                        ;=====================================================
                        ; This macro is used to verify that the current addres
                        ; meets a required value.  Used mostly to guarantee
                        ; changes don't cause entry points to move.
                        ;
                        VERIFY		macro	expected
                        		if * != expected
                        		fail	Not at requested address (expected)
                        		endif
                        		endm
                        ;
                        ;=====================================================
                        ; KIM memory locations
                        ;
                        		bss
00ef =                  		org	$00ef
00ef =                  PCL		ds	1
00f0 =                  PCH		ds	1
00f1 =                  PREG		ds	1
00f2 =                  SPUSER		ds	1
00f3 =                  ACC		ds	1
00f4 =                  YREG		ds	1
00f5 =                  XREG		ds	1
00f6 =                  CHKHI		ds	1
00f7 =                  CHKSUM		ds	1
00f8 =                  INL	    	ds	1
00f9 =                  INH		ds	1
00fa =                  POINTL		ds	1
00fb =                  POINTH		ds	1
00fc =                  TEMP		ds	1
00fd =                  TMPX		ds	1
00fe =                  CHAR		ds	1
00ff =                  MODE		ds	1
                        ;
17e7 =                  		org	$17e7
17e7 =                  CHKL		ds	1
17e8 =                  CHKH		ds	1
17e9 =                  SAVX		ds	3
17ec =                  VEB	    	ds	6
17f2 =                  CNTL30		ds	1
17f3 =                  CNTH30		ds	1
17f4 =                  TIMH		ds	1
17f5 =                  SAL		ds	1
17f6 =                  SAH	    	ds	1
AS65 Assembler for R6502 [1.42].                                     Page    4
---------------------------------- xKIM.asm ----------------------------------

17f7 =                  EAL		ds	1
17f8 =                  EAH	    	ds	1
17f9 =                  ID  		ds	1
                        ;
                        ;=====================================================
                        ; KIM I/O locations
                        ;
1740 =                  SAD		equ	$1740
1741 =                  PADD		equ	$1741
                        ;
                        ;=====================================================
                        ; KIM subroutines located in the ROMs
                        ;
1c1c =                  NMIT		equ	$1c1c	;NMI handler
1c1f =                  IRQT		equ	$1c1f	;IRQ handler
1c22 =                  RST	    	equ	$1c22	;RESET handler
1c77 =                  TTYKB		equ	$1c77	;do keyboard monitor
1e2f =                  CRLF		equ	$1e2f	;print CR/LF
1e1e =                  PRTPNT		equ	$1e1e	;print POINT
1e3b =                  PRTBYT		equ	$1e3b	;print A as two hex digits
1e5a =                  GETCH		equ	$1e5a	;get a key from tty into A
1e9e =                  OUTSP		equ	$1e9e	;print a space
1ea0 =                  OUTCH		equ	$1ea0	;print A to TTY
1dac =                  SHOW		equ	$1dac
1daf =                  SHOW1		equ	$1daf
1f63 =                  INCPT		equ	$1f63	;inc POINTL/POINTH
                        ;
                        ;=====================================================
                        ; KIM IEC save and load memory locations
                        ;
17f5 =                  IECSAL		equ $17F5
17f6 =                  IECSAH		equ $17F6
17f7 =                  IECEAL		equ $17F7
17f8 =                  IECEAH		equ $17F8
17f9 =                  IECFID		equ $17F9
f148 =                  IECSAV		equ $F148
f000 =                  IECLOD		equ $F000
                        ;
17fa =                  NMIL		equ $17FA
17fb =                  NMIH		equ $17FB
17fc =                  RSTL		equ $17FC
17fd =                  RSTH		equ $17FD
17fe =                  IRQL		equ $17FE
17ff =                  IRQH		equ $17FF
                        ;
                        ;=====================================================
                        ; I assume the RAM goes from 2000 to DFFF, so carve ou
                        ; a bit for use by the monitor.
                        ;
                        		bss		;uninitialized data area
                        	if	RAM_BASED
                        		org     RAM_DATA_BASE
                        	else
df80 =                  		org	RAM_START
                        	endif
df80 =                  LowestAddress	equ	*
                        ;
                        ; Storage for registers for some monitor calls.
                        ;
df80 =                  saveA		ds	1
df81 =                  saveX		ds	1
df82 =                  saveY		ds	1
AS65 Assembler for R6502 [1.42].                                     Page    5
---------------------------------- xKIM.asm ----------------------------------

                        
df83 =                  saveNMIL	ds	1
df84 =                  saveNMIH	ds	1
df85 =                  saveRSTL	ds	1
df86 =                  saveRSTH	ds	1
df87 =                  saveIRQL	ds	1
df88 =                  saveIRQH	ds	1
                        
                        ;
                        ; Pointer to the subroutine that gets the next input
                        ; character.  Used for doing disk/console input.
                        ;
df89 =                  inputVector	ds	2
                        ;
                        ; Same thing for output.
                        ;
df8b =                  outputVector	ds	2
                        ;
df8d =                  filename	ds	FILENAME_SIZE+1
df9a =                  buffer		ds	BUFFER_SIZE
dfda =                  diskBufOffset	ds	1
dfdb =                  diskBufLength	ds	1
                        ;
dfdc =                  Temp16L		ds	1
dfdd =                  Temp16H		ds	1
df81 =                  byteCount	equ	saveX
                        ;
                        ; The clock functions need some storage, but just
                        ; overlay the names onto the buffer.
                        ;
df9a =                  month		equ	buffer
df9b =                  day		equ	month+1
df9c =                  year_high	equ	day+1
df9d =                  year_low	equ	year_high+1
df9e =                  hour		equ	year_low+1
df9f =                  minute		equ	hour+1
dfa0 =                  second		equ	minute+1
dfa1 =                  day_of_week	equ	second+1
dfa2 =                  clock_end	equ	day_of_week+1
                        ;
                        ; The next group of memory are public and can be
                        ; used by user programs, so don't modify where any
                        ; of these are.  If you want to add new public data,
                        ; put them here, always before existing items.  Be
                        ; sure to adjust the ORG.
                        ;
                        	if	RAM_BASED
                        		org	RAM_CODE_BASE-8
                        	else
dff8 =                  		org	ROM_START-8
                        	endif
                        ;
                        ; Before loading a hex file, the MSB of this vector
                        ; is set to FF.  After loading the file, if the MSB
                        ; is no longer FF then the address in this vector is
                        ; jumped to.  Ie, it can auto-run a file.
                        ;
dff8 =                  AutoRun		ds	2
                        ;
                        ; ColdFlag is used to determine if the extended
                        ; monitoring is doing a warm or cold start.
                        ;
AS65 Assembler for R6502 [1.42].                                     Page    6
---------------------------------- xKIM.asm ----------------------------------

dffa =                  ColdFlag	ds	2
                        ;
                        ; Address of a command table for user-created
                        ; extensions to the monitor.
                        ;
dffc =                  ExtensionAddr	ds	2
                        ;
                        ; This is the higest location in RAM usable by user
                        ; programs.  Nobody should go past this address.  If
                        ; you are writing extentions to the monitor, it's
                        ; okay to load before the address and then adjust
                        ; this down to keep others from stomping on your
                        ; extention.
                        ;
                        ; If your program modifies this value, it needs to
                        ; set it back before terminating.
                        ;
dffe =                  HighestAddress	ds	2
                        		page
AS65 Assembler for R6502 [1.42].                                     Page    7
---------------------------------- xKIM.asm ----------------------------------

                        ;
                        ; VecFlag is used to determine if we need to restore
                        ; interrupt vector addresses
                        ;
e000 =                  VecFlag	ds	2
                        ;=====================================================
                        ; Code starts at E000 and goes until FFFF, except for
                        ; the 6502 vectors at the end of memory.
                        ;
                        		code
                        	if	RAM_BASED
                        		org	RAM_CODE_BASE
                        	else
e000 =                  		org	ROM_START
                        	endif
                        ;
                        ; Vector table of useful and fun stuff!  These must
                        ; not change or else existing code won't be calling
                        ; the right functions.
                        ;
e000 =                  BASE		equ	*
e000 : 4c60e0           reentry		jmp	extKim	;extended monitor
e003 : 4ca01e           		jmp	OUTCH	;output A to console
e006 : 4c5a1e           		jmp	GETCH	;get a key and echo
e009 : 4c5a1e           		jmp	GETCH	;no echo - KIM can't do it
e00c : 4c5ae0           		jmp	dummyRet	;future - console stat
e00f : 4cd1ea           		jmp	putsil	;print string after JSR
e012 : 4c00eb           		jmp	getHex	;get hex value in A
e015 : 4c3b1e           		jmp	PRTBYT	;print A as hex
e018 : 4c38eb           		jmp	getStartAddr
e01b : 4c4aeb           		jmp	getEndAddr
e01e : 4c5ceb           		jmp	getAddrRange
e021 : 4c50e4           		jmp	doHexDump	;perform a hex dump
e024 : 4cebe5           		jmp	doEdit		;edit memory
e027 : 4c09e7           		jmp	loadHexConsole	;load hex file via console
e02a : 4cdae6           		jmp	loadHexFile	;load hex file from SD
e02d : 4c9be9           		jmp	doSDDiskDir	;do a disk directory
e030 : 4c6deb           		jmp	ComputeOffset	;compute relative offset
                        ;
                        ; SD card functions
                        ;
                        		VERIFY	BASE+$0033
                        
e033 : 4c78ec           		jmp	xParInit	;initialization
e036 : 4c92ec           		jmp	xParSetWrite
e039 : 4ca2ec           		jmp	xParSetRead
e03c : 4cb0ec           		jmp	xParWriteByte
e03f : 4cdbec           		jmp	xParReadByte
e042 : 4cffec           		jmp	DiskPing
e045 : 4c12ed           		jmp	DiskDir
e048 : 4c1ced           		jmp	DiskDirNext
e04b : 4c4ded           		jmp	DiskOpenRead
e04e : 4c7eed           		jmp	DiskRead
e051 : 4ce7ed           		jmp	DiskClose
e054 : 4c79ed           		jmp	DiskOpenWrite
e057 : 4cb0ed           		jmp	DiskWrite
                        ;
                        ; Even more vectors as I ran out of the reserve area!
                        ;
                        
                        ;
                        ;=====================================================
AS65 Assembler for R6502 [1.42].                                     Page    8
---------------------------------- xKIM.asm ----------------------------------

                        ;=====================================================
                        ; Anything past this point can be moved in future
                        ; releases so none of these functions nor data should
                        ; be directly accessed by user programs!!!
                        ;=====================================================
                        ;=====================================================
                        ; This is a dummy function for unimplemented functions
                        ; that basically just clears carry and returns.
                        ;
e05a : 18               dummyRet	clc
e05b : 60               		rts
                        ;
e05c : 00               defaultExt	db	0
                        		page
AS65 Assembler for R6502 [1.42].                                     Page    9
---------------------------------- xKIM.asm ----------------------------------

                        ;=====================================================
                        ; This is the start of the extended KIM monitor.
                        ;
e05d : 4c771c           notty		jmp	TTYKB
e060 : a2ff             extKim		ldx	#$ff
e062 : 9a               		txs
e063 : a901             		lda	#$01	;see if in tty mode
e065 : 2c4017           		bit	SAD
e068 : d0f3             		bne	notty	;branch if in keyboard mode
                        
                        	if	~SD_ONLY_COLD
e06a : 2078ec           		jsr	xParInit
                        	endif
                        ;
                        ; Determine if this is a cold or warm start
                        ;
e06d : adfadf           		lda	ColdFlag
e070 : c919             		cmp	#COLD_FLAG_1
e072 : d01b             		bne	coldStart
e074 : adfbdf           		lda	ColdFlag+1
e077 : c962             		cmp	#COLD_FLAG_2
e079 : d014             		bne	coldStart
                        		
e07b : ad00e0           		lda	VecFlag
e07e : c9ab             		cmp	#VEC_FLAG_1
e080 : d00a             		bne warmboot
e082 : ad01e0           		lda	VecFlag+1
e085 : c9ab             		cmp	#VEC_FLAG_2
e087 : d003             		bne	warmboot
                        		
e089 : 204eef           		jsr loadvec
                        		
e08c : 4c40e1           warmboot	jmp	extKimLoop	;it's a warm start
                        ;
                        ; Cold start
                        ;
e08f : d8               coldStart	cld	
e090 : a919             		lda	#COLD_FLAG_1	;indicate we've done cold
e092 : 8dfadf           		sta	ColdFlag
e095 : a962             		lda	#COLD_FLAG_2
e097 : 8dfbdf           		sta	ColdFlag+1
                        ;
                        ; Point to an empty extension set by default.
                        ;
e09a : a95c             		lda	#defaultExt&$ff	;set extension pointers
e09c : 8dfcdf           		sta	ExtensionAddr
e09f : a9e0             		lda	#defaultExt/256
e0a1 : 8dfddf           		sta	ExtensionAddr+1
                        ;
                        ; Set HighestAddress to just before our RAM area.
                        ;
e0a4 : a97f             		lda	#(LowestAddress-1)&$ff
e0a6 : 8dfedf           		sta	HighestAddress
e0a9 : a9df             		lda	#(LowestAddress-1)/256
e0ab : 8dffdf           		sta	HighestAddress+1
                        	if	SD_ONLY_COLD
                        ;
                        ; Initialize the interface to the SD card.  There seem
                        ; be a problem if this is done too often, so do it jus
                        ; and be done.
                        ;
                        		jsr	xParInit
AS65 Assembler for R6502 [1.42].                                     Page   10
---------------------------------- xKIM.asm ----------------------------------

                        	endif
                        ;
                        ; Display our welcome text
                        ;
e0ae : 20d1ea           		jsr	putsil
e0b1 : 0d0a0d0a         		db	CR,LF,CR,LF
e0b5 : 457874656e6465.. 		db	"Extended KIM Monitor v"
e0cb : 312e3920         		db	VERSION+'0','.',REVISION+'0',' '
                        	if	BETA_VER
                        		db	"BETA "
                        		db	BETA_VER+'0'
                        		db	' '
                        	endif
e0cf : 62792052657472.. 		db  "by RetroSpy Technologies"
e0e7 : 0d0a             		db	CR,LF				
e0e9 : 726574726f2d73.. 		db  "retro-spy.com"
e0f6 : 0d0a             		db	CR,LF
e0f8 : 0d0a             		db	CR,LF
e0fa : 4261736564206f.. 		db	"Based on the work of Corsham Technologies, LLC"
e128 : 0d0a             		db	CR,LF
e12a : 7777772e636f72.. 		db	"www.corshamtech.com"
e13d : 0d0a             		db	CR,LF
                        	if	RAM_BASED
                        		db	CR,LF
                        		db	"*** RAM BASED VERSION ***"
                        		db	CR,LF
                        	endif
e13f : 00               		db	0
                        ;
                        ; Main command loop.  Put out prompt, get command, etc
                        ; Prints a slightly different prompt for the RAM versi
                        ;
e140 : d8               extKimLoop	cld
e141 : 20f7eb           		jsr	setInputConsole
e144 : 20d1ea           		jsr	putsil	;output prompt
e147 : 0d0a             		db	CR,LF	;feel free to change it
                        	if	RAM_BASED
                        		db	"RAM"
                        	endif
e149 : 3e00             		db	">",0
e14b : 205a1e           		jsr	GETCH
e14e : c90d             		cmp	#CR
e150 : f0ee             		beq	extKimLoop
e152 : c90a             		cmp	#LF
e154 : f0ea             		beq	extKimLoop
e156 : 85f3             		sta	ACC	;save key
                        ;
                        ; Now cycle through the list of commands looking for
                        ; what the user just pressed.
                        ;
e158 : a97e             		lda	#commandTable&$ff
e15a : 85fa             		sta	POINTL
e15c : a9e1             		lda	#commandTable/256
e15e : 85fb             		sta	POINTH
e160 : 207fea           		jsr	searchCmd	;try to find it
                        ;
                        ; Hmmm... wasn't one of the built in commands, so
                        ; see if it's an extended command.
                        ;
e163 : adfcdf           		lda	ExtensionAddr
e166 : 85fa             		sta	POINTL
e168 : adfddf           		lda	ExtensionAddr+1
AS65 Assembler for R6502 [1.42].                                     Page   11
---------------------------------- xKIM.asm ----------------------------------

e16b : 85fb             		sta	POINTH
e16d : 207fea           		jsr	searchCmd
                        ;
                        ; If that returns, then the command was not found.
                        ; Print that it's unknown.
                        ;
e170 : 20d1ea           		jsr	putsil
e173 : 202d204875683f00 		db	" - Huh?",0
e17b : 4c40e1           cmdFound	jmp	extKimLoop
                        ;
                        ;=====================================================
                        ; Vector table of commands.  Each entry consists of a
                        ; single ASCII character (the command), a pointer to
                        ; the function which handles the command, and a pointe
                        ; to a string that describes the command.
                        ;
e17e : 3f               commandTable	db	'?'
e17f : e9e3             		dw	showHelp
e181 : d4e1             		dw	quesDesc
                        ;
                        	if	TINY_BASIC
                        		db	'B'
                        		dw	TBasicCold
                        		dw	bDesc
                        	endif
                        ;
                        	if	SHOW_RTC
e183 : 43               		db	'C'
e184 : eced             		dw	doShowClock
e186 : f1e1             		dw	cDesc
                        	endif
e188 : 44               		db	'D'
e189 : 7ee9             		dw	doDiskDir
e18b : 0ae2             		dw	dDesc
                        ;
e18d : 45               		db	'E'	;edit memory
e18e : d0e5             		dw	editMemory
e190 : 27e2             		dw	eDesc
                        ;
e192 : 48               		db	'H'	;hex dump
e193 : 42e4             		dw	hexDump
e195 : 41e2             		dw	hDesc
                        ;
e197 : 4a               		db	'J'	;jump to address
e198 : 4ee9             		dw	jumpAddress
e19a : 5fe2             		dw	jDesc
                        ;
e19c : 4b               		db	'K'	;return to KIM monitor
e19d : bde3             		dw	returnKim
e19f : 7de2             		dw	kDesc
                        ;
e1a1 : 4c               		db	'L'	;load Intel HEX file
e1a2 : 7ee6             		dw	loadHex
e1a4 : 9de2             		dw	lDesc
                        ;
e1a6 : 4d               		db	'M'	;perform memory test
e1a7 : d5e4             		dw	memTest
e1a9 : b9e2             		dw	mDesc
                        ;
e1ab : 4f               		db	'O'	;branch offset calculator
e1ac : 0fea             		dw	offCalc
e1ae : d3e2             		dw	oDesc
AS65 Assembler for R6502 [1.42].                                     Page   12
---------------------------------- xKIM.asm ----------------------------------

                        ;
e1b0 : 50               		db	'P'	;ping remote disk
e1b1 : 5fe9             		dw	pingDisk
e1b3 : f9e2             		dw	pDesc
                        ;
e1b5 : 53               		db	'S'	;save memory as hex file
e1b6 : 15e8             		dw	saveHex
e1b8 : 1ce3             		dw	sDesc
                        ;
e1ba : 54               		db	'T'	;type a file on SD
e1bb : bae9             		dw	typeFile
e1bd : 3ee3             		dw	tDesc
                        ;
e1bf : 58               		db	'X'	;return to KIM monitor
e1c0 : bde3             		dw	returnKim
e1c2 : 7de2             		dw	kDesc
                        ;
e1c4 : 59               		db	'Y'	;save memory to IEC
e1c5 : 81ee             		dw	saveIEC
e1c7 : 5be3             		dw	yDesc
                        ;
e1c9 : 5a               		db	'Z'	;load memory from IEC
e1ca : d1ee             		dw	loadIEC
e1cc : 7ce3             		dw	zDesc
                        ;
e1ce : 21               		db	'!'	;do cold restart
e1cf : e3e3             		dw	doCold
e1d1 : 9fe3             		dw	bangDesc
                        ;
e1d3 : 00               		db	0	;marks end of table
                        ;
                        ;=====================================================
                        ; Descriptions for each command in the command table.
                        ; This wastes a lot of space... I'm open for any
                        ; suggestions to keep the commands clear but reducing
                        ; the amount of space this table consumes.
                        ;
e1d4 : 3f202e2e2e2e2e.. quesDesc	db	"? ........... Show this help",0
                        	if	TINY_BASIC
                        bDesc		db	"B ........... Bob's Tiny BASIC",0
                        	endif
                        	if	SHOW_RTC
e1f1 : 43202e2e2e2e2e.. cDesc		db	"C ........... Show clock",0
                        	endif
e20a : 44202e2e2e2e2e.. dDesc		db	"D ........... Disk directory",0
e227 : 45207878787820.. eDesc		db	"E xxxx ...... Edit memory",0
e241 : 48207878787820.. hDesc		db	"H xxxx xxxx . Hex dump memory",0
e25f : 4a207878787820.. jDesc		db	"J xxxx ...... Jump to address",0
e27d : 4b202e2e2e2e2e.. kDesc		db	"K ........... Go to KIM monitor",0
e29d : 4c202e2e2e2e2e.. lDesc		db	"L ........... Load HEX file",0
e2b9 : 4d207878787820.. mDesc		db	"M xxxx xxxx . Memory test",0
e2d3 : 4f207878787820.. oDesc		db	"O xxxx xxxx . Calculate branch offset",0
e2f9 : 50202e2e2e2e2e.. pDesc		db	"P ........... Ping disk controller",0
e31c : 53207878787820.. sDesc		db	"S xxxx xxxx . Save memory to file",0
e33e : 54202e2e2e2e2e.. tDesc		db	"T ........... Type disk file",0
e35b : 5920787878782d.. yDesc		db  "Y xxxx-xxxx . Save memory to IEC",0
e37c : 5a202e2e2e2e2e.. zDesc		db 	"Z ........... Load memory from IEC",0
e39f : 21202e2e2e2e2e.. bangDesc	db	"! ........... Do a cold start",0
                        ;
                        ;=====================================================
                        ; Return to KIM monitor.  Before returning, set the
                        ; "open address" to the start of the extended monitor
AS65 Assembler for R6502 [1.42].                                     Page   13
---------------------------------- xKIM.asm ----------------------------------

                        ; so the KIM monitor is pointing to it by default.
                        ;
e3bd : 20d1ea           returnKim	jsr	putsil
e3c0 : 0d0a             		db	CR,LF
e3c2 : 52657475726e69.. 		db	"Returning to KIM..."
e3d5 : 0d0a00           		db	CR,LF,0
e3d8 : a900             		lda	#reentry&$0ff
e3da : 85fa             		sta	POINTL	;point back to start...
e3dc : a9e0             		lda	#reentry/256
e3de : 85fb             		sta	POINTH	;...of this code
e3e0 : 4caf1d           		jmp	SHOW1	;return to KIM
                        ;
                        ;=====================================================
                        ; Force a cold start.
                        ;
e3e3 : eefadf           doCold		inc	ColdFlag	;foul up flag
e3e6 : 4c60e0           		jmp	extKim		;...and restart
                        ;
                        ;=====================================================
                        ; Command handler for the ? command
                        ;
e3e9 : 20d1ea           showHelp	jsr	putsil
e3ec : 0d0a             		db	CR,LF
e3ee : 417661696c6162.. 		db	"Available commands:"
e401 : 0d0a0a00         		db	CR,LF,LF,0
                        ;
                        ; Print help for built-in commands...
                        ;
e405 : a97e             		lda	#commandTable&$ff
e407 : 85fa             		sta	POINTL
e409 : a9e1             		lda	#commandTable/256
e40b : 85fb             		sta	POINTH
e40d : 20a2ea           		jsr	displayHelp	;display help
                        ;
                        ; Now print help for the extension commands...
                        ;
e410 : adfcdf           		lda	ExtensionAddr
e413 : 85fa             		sta	POINTL
e415 : adfddf           		lda	ExtensionAddr+1
e418 : 85fb             		sta	POINTH
e41a : 20a2ea           		jsr	displayHelp
e41d : 202f1e           		jsr	CRLF
e420 : 4c40e1           		jmp	extKimLoop
                        ;
                        ;=====================================================
                        ; This is a generic "not done yet" holder.  Any
                        ; unimplemented commands should point here.
                        ;
e423 : 20d1ea           NDY		jsr	putsil
e426 : 0d0a             		db	CR,LF
e428 : 536f7272792c20.. 		db	"Sorry, not done yet."
e43c : 0d0a00           		db	CR,LF,0
e43f : 4c40e1           NDYdone		jmp	extKimLoop
                        ;
                        ;=====================================================
                        ; Do a hex dump of a region of memory.  This code was
                        ; taken from MICRO issue 5, from an article by
                        ; J.C. Williams.  I changed it a bit, but it's still
                        ; basically the same code.
                        ;
                        ; Slight bug: the starting address is rounded down to
                        ; a multiple of 16.  I'll fix it eventually.
AS65 Assembler for R6502 [1.42].                                     Page   14
---------------------------------- xKIM.asm ----------------------------------

                        ;
e442 : 205ceb           hexDump		jsr	getAddrRange
e445 : b0f8             		bcs	NDYdone
e447 : 202f1e           		jsr	CRLF
e44a : 2050e4           		jsr	doHexDump	;subroutine does it
e44d : 4c40e1           cmdRet2		jmp	extKimLoop
                        ;
                        ;=====================================================
                        ; This subroutine does a hex dump from the address in
                        ; SAL/H to EAL/H.
                        ;
                        ; Move start address to POINT but rounded down to the
                        ; 16 byte boundary.
                        ;
e450 : adf617           doHexDump	lda	SAH
e453 : 85fb             		sta	POINTH
e455 : adf517           		lda	SAL
e458 : 29f0             		and	#$f0	;force to 16 byte
e45a : 85fa             		sta	POINTL
                        ;
                        ; This starts each line.  Set flag to indcate we're
                        ; doing the hex portion, print address, etc.
                        ;
e45c : a900             hexdump1	lda	#0	;set flag to hex mode
e45e : 8df917           		sta	ID
e461 : 202f1e           		jsr	CRLF
e464 : 201e1e           		jsr	PRTPNT	;print the address
e467 : a5fa             hexdump2	lda	POINTL	;push start of line...
e469 : 48               		pha		;...address onto stack
e46a : a5fb             		lda	POINTH
e46c : 48               		pha
e46d : 20cbea           		jsr	space2
e470 : a20f             		ldx	#BYTESLINE-1	;number of bytes per line
e472 : 20cbea           		jsr	space2	;space before data
                        
e475 : a000             hexdump3	ldy	#0	;get next byte...
e477 : b1fa             		lda	(POINTL),y
e479 : 2cf917           		bit	ID	;hex or ASCII mode?
e47c : 1010             		bpl	hexptbt	;branch if hex mode
                        ;
                        ; Print char if printable, else print a dot
                        ;
e47e : c920             		cmp	#' '
e480 : 9004             		bcc	hexdot
e482 : c97e             		cmp	#'~'
e484 : 9002             		bcc	hexpr
e486 : a92e             hexdot		lda	#'.'
e488 : 20a01e           hexpr		jsr	OUTCH
e48b : 4c94e4           		jmp	hexend
                        ;
                        ; Print character as hex.  
                        ;
e48e : 203b1e           hexptbt 	jsr	PRTBYT	;print as hex
e491 : 20ceea           		jsr	space	;and follow with a space
                        ;
                        ; See if we just dumped the last address.  If not, the
                        ; increment to the next address and continue.
                        ;
e494 : a5fa             hexend  	lda	POINTL	;compare first
e496 : cdf717           		cmp	EAL
e499 : a5fb             		lda	POINTH
e49b : edf817           		sbc	EAH
AS65 Assembler for R6502 [1.42].                                     Page   15
---------------------------------- xKIM.asm ----------------------------------

                        ;
                        ; Now increment to the next address
                        ;
e49e : 08               		php
e49f : 20631f           		jsr	INCPT
e4a2 : 28               		plp
e4a3 : 901a             		bcc	hexlntst
                        ;
e4a5 : 2cf917           		bit	ID
e4a8 : 3022             		bmi	hexdone
e4aa : ca               		dex
e4ab : 3006             		bmi	hexdomap
e4ad : 20c8ea           hexdump5	jsr	space3
e4b0 : ca               		dex
e4b1 : 10fa             		bpl	hexdump5
e4b3 : cef917           hexdomap	dec	ID
e4b6 : 68               		pla
e4b7 : 85fb             		sta	POINTH
e4b9 : 68               		pla
e4ba : 85fa             		sta	POINTL
e4bc : 4c67e4           		jmp     hexdump2
e4bf : ca               hexlntst	dex
e4c0 : 10b3             		bpl	hexdump3
e4c2 : 2cf917           		bit	ID
e4c5 : 10ec             		bpl	hexdomap
e4c7 : 68               		pla
e4c8 : 68               		pla
e4c9 : 4c5ce4           		jmp	hexdump1
                        ;
                        ; Clean up the stack and we're done
                        ;
e4cc : 202f1e           hexdone		jsr	CRLF
e4cf : 68               		pla
e4d0 : 68               		pla
e4d1 : 60               		rts
                        ;
                        ;=====================================================
                        ; This does a memory test of a region of memory.  One
                        ; problem with the KIM is that there is no routine to
                        ; see if a new character is starting, so this loop
                        ; just runs forever unless the user presses RESET.
                        ;
                        ; Asks for the starting and ending locations.
                        ;
                        ; This cycles a rolling bit, then adds a ninth
                        ; pattern to help detect shorted address bits.
                        ; Ie: 01, 02, 04, 08, 10, 20, 40, 80, BA
                        ;
17e7 =                  pattern		equ	CHKL		;re-use some KIM locations
17e8 =                  original	equ	CHKH
                        ;
                        ; Test patterns
                        ;
0001 =                  PATTERN_0	equ	$01
00ba =                  PATTERN_9	equ	$ba
                        ;
e4d2 : 4c40e1           cmdRet5		jmp	extKimLoop
e4d5 : 205ceb           memTest		jsr	getAddrRange	;get range
e4d8 : b0f8             		bcs	cmdRet5		;branch if abort
                        ;
e4da : 20d1ea           		jsr	putsil
e4dd : 0d0a             		db	CR,LF
AS65 Assembler for R6502 [1.42].                                     Page   16
---------------------------------- xKIM.asm ----------------------------------

e4df : 54657374696e67.. 		db	"Testing memory.  Press RESET to abort"
e504 : 00               		db	0
e505 : a901             		lda	#PATTERN_0	;only set initial...
e507 : 8de717           		sta	pattern		;..pattern once
                        ;
                        ; Start of loop.  This fills/tests one complete pass
                        ; of memory.
                        ;
e50a : adf517           memTestMain	lda	SAL	;reset pointer to start
e50d : 85fa             		sta	POINTL
e50f : adf617           		lda	SAH
e512 : 85fb             		sta	POINTH
                        ;
                        ; Fill memory with the rolling pattern until the last
                        ; location is filled.
                        ;
e514 : a000             		ldy	#0
e516 : ade717           		lda	pattern
e519 : 8de817           		sta	original
e51c : 91fa             memTestFill	sta	(POINTL),y
e51e : c9ba             		cmp	#PATTERN_9	;at last pattern?
e520 : d005             		bne	memFill3
e522 : a901             		lda	#PATTERN_0	;restart pattern
e524 : 4c2ce5           		jmp	memFill4
                        ;
                        ; Rotate pattern left one bit
                        ;
e527 : 0a               memFill3	asl	a
e528 : 9002             		bcc	memFill4	;branch if not overflow
e52a : a9ba             		lda	#PATTERN_9	;ninth pattern
                        ;
                        ; The new pattern is in A.  Now see if we've reached
                        ; the end of the area to be tested.
                        ;
e52c : 48               memFill4	pha			;save pattern
e52d : a5fa             		lda	POINTL
e52f : cdf717           		cmp	EAL
e532 : d007             		bne	memFill5
e534 : a5fb             		lda	POINTH
e536 : cdf817           		cmp	EAH
e539 : f007             		beq	memCheck
                        ;
                        ; Not done, so move to next address and keep going.
                        ;
e53b : 20631f           memFill5	jsr	INCPT
e53e : 68               		pla			;recover pattern
e53f : 4c1ce5           		jmp	memTestFill
                        ;
                        ; Okay, memory is filled, so now go back and test it.
                        ; We kept a backup copy of the initial pattern to
                        ; use, but save the current pattern as the starting
                        ; point for the next pass.
                        ;
e542 : 68               memCheck	pla
e543 : 8de717           		sta	pattern		;for next pass
e546 : adf517           		lda	SAL		;reset pointer to start
e549 : 85fa             		sta	POINTL
e54b : adf617           		lda	SAH
e54e : 85fb             		sta	POINTH
e550 : ade817           		lda	original	;restore initial pattern
e553 : a000             		ldy	#0
e555 : d1fa             memTest2	cmp	(POINTL),y
AS65 Assembler for R6502 [1.42].                                     Page   17
---------------------------------- xKIM.asm ----------------------------------

e557 : d02c             		bne	memFail
e559 : c9ba             		cmp	#PATTERN_9
e55b : d004             		bne	memTest3
                        ;
                        ; Time to reload the pattern
                        ;
e55d : a901             		lda	#PATTERN_0
e55f : d005             		bne	memTest4
                        ;
                        ; Rotate pattern left one bit
                        ;
e561 : 0a               memTest3	asl	a
e562 : 9002             		bcc	memTest4
e564 : a9ba             		lda	#PATTERN_9
                        ;
                        ; The new pattern is in A.
                        ;
e566 : 48               memTest4	pha			;save pattern
e567 : a5fa             		lda	POINTL
e569 : cdf717           		cmp	EAL
e56c : d007             		bne	memTest5	;not at end
e56e : a5fb             		lda	POINTH
e570 : cdf817           		cmp	EAH
e573 : f007             		beq	memDone		;at end of pass
                        ;
                        ; Not at end yet, so inc pointer and continue
                        ;
e575 : 20631f           memTest5	jsr	INCPT
e578 : 68               		pla
e579 : 4c55e5           		jmp	memTest2
                        ;
                        ; Another pass has completed.
                        ;
e57c : 68               memDone		pla
e57d : a92e             		lda	#'.'
e57f : 20a01e           		jsr	OUTCH
e582 : 4c0ae5           		jmp	memTestMain
                        ;
                        ; Failure.  Display the failed address, the expected
                        ; value and what was actually there.
                        ;
e585 : 48               memFail		pha		;save pattern for error report
e586 : 20d1ea           		jsr	putsil
e589 : 0d0a             		db	CR,LF
e58b : 4661696c757265.. 		db	"Failure at address ",0
e59f : 201e1e           		jsr	PRTPNT
e5a2 : 20d1ea           		jsr	putsil
e5a5 : 2e202045787065.. 		db	".  Expected ",0
e5b2 : 68               		pla
e5b3 : 203b1e           		jsr	PRTBYT
e5b6 : 20d1ea           		jsr	putsil
e5b9 : 2062757420676f.. 		db	" but got ",0
e5c3 : a000             		ldy	#0
e5c5 : b1fa             		lda	(POINTL),y
e5c7 : 203b1e           		jsr	PRTBYT
e5ca : 202f1e           		jsr	CRLF
e5cd : 4c40e1           cmdRet4		jmp	extKimLoop
                        ;
                        ;=====================================================
                        ; Edit memory.  This waits for a starting address to b
                        ; entered.  It will display the current address and it
                        ; contents.  Possible user inputs and actions:
AS65 Assembler for R6502 [1.42].                                     Page   18
---------------------------------- xKIM.asm ----------------------------------

                        ;
                        ;   Two hex digits will place that value in memory
                        ;   RETURN moves to next address
                        ;   BACKSPACE moves back one address
                        ;
e5d0 : 20ceea           editMemory      jsr	space
e5d3 : 2038eb           		jsr	getStartAddr
e5d6 : b0f5             		bcs	cmdRet4
e5d8 : adf517           		lda	SAL		;move address into...
e5db : 85fa             		sta	POINTL		;...POINT
e5dd : adf617           		lda	SAH
e5e0 : 85fb             		sta	POINTH
e5e2 : 202f1e           		jsr	CRLF
e5e5 : 20ebe5           		jsr	doEdit
e5e8 : 4c40e1           		jmp	extKimLoop
                        ;
                        ;=====================================================
                        ; This subroutine edits memory.  On entry, POINT has
                        ; the first address to edit.  Upon exit, POINT will
                        ; have been updated to next address to edit.
                        ;
                        ; Display the current location
                        ;
e5eb : 201e1e           doEdit		jsr	PRTPNT		;print address
e5ee : 20ceea           		jsr	space
e5f1 : a000             		ldy	#0
e5f3 : b1fa             		lda	(POINTL),y	;get byte
e5f5 : 203b1e           		jsr	PRTBYT		;print it
e5f8 : 20ceea           		jsr	space
                        ;
e5fb : 2000eb           		jsr	getHex
e5fe : b00d             		bcs	editMem2	;not hex
e600 : a000             editMem7	ldy	#0
e602 : 91fa             		sta	(POINTL),y	;save new value
                        ;
                        ; Bump POINT to next location
                        ;
e604 : 202f1e           editMem3	jsr	CRLF
e607 : 20631f           		jsr	INCPT
e60a : 4cebe5           		jmp	doEdit
                        ;
                        ; Not hex, so see if another command.  Valid commands 
                        ;
                        ;    CR = advance to next memory location
                        ;    BS = move to previous location
                        ;    R  = compute relative offset
                        ;
e60d : c952             editMem2	cmp	#'R'		;compute relative branch
e60f : f017             		beq	editMem4
e611 : c90d             		cmp	#CR
e613 : f0ef             		beq	editMem3	;move to next
e615 : c908             		cmp	#BS
e617 : d00e             		bne     editexit		;else exit
                        ;
                        ; Move back one location
                        ;
e619 : a5fa             		lda	POINTL
e61b : d002             		bne	editMem8
e61d : c6fb             		dec	POINTH
e61f : c6fa             editMem8	dec	POINTL
e621 : 202f1e           		jsr	CRLF
e624 : 4cebe5           		jmp	doEdit
AS65 Assembler for R6502 [1.42].                                     Page   19
---------------------------------- xKIM.asm ----------------------------------

                        ;
e627 : 60               editexit	rts
                        ;
                        ; They want to calculate a relative offset
                        ;
e628 : 20d1ea           editMem4	jsr	putsil
e62b : 656c6174697665.. 		db	"elative offset to: ",0
e63f : 204aeb           		jsr	getEndAddr
e642 : b0a7             		bcs	doEdit		;bad input
                        ;
                        ; Need to load POINTL/POINTH into SAL/SAH and then
                        ; decrement by one.
                        ;
e644 : a5fb             		lda	POINTH
e646 : 8df617           		sta	SAH
e649 : a5fa             		lda	POINTL
e64b : 8df517           		sta	SAL
e64e : d003             		bne	editMem5
e650 : cef617           		dec	SAH
e653 : cef517           editMem5	dec	SAL
                        ;
e656 : 206deb           		jsr	ComputeOffset
e659 : 9016             		bcc	editMem6	;value good
e65b : 20d1ea           		jsr	putsil
e65e : 202d206f757420.. 		db	" - out of range",0
e66e : 4cebe5           		jmp	doEdit
                        ;
                        ; Relative offset is in A.
                        ;
e671 : 48               editMem6	pha
e672 : 20ceea           		jsr	space
e675 : 68               		pla
e676 : 48               		pha
e677 : 203b1e           		jsr	PRTBYT		;print it
e67a : 68               		pla
e67b : 4c00e6           		jmp	editMem7	;store it
                        ;
                        ;=====================================================
                        ; This handles the Load hex command.
                        ;
e67e : 20d1ea           loadHex		jsr	putsil
e681 : 0d0a             		db	CR,LF
e683 : 456e7465722066.. 		db	"Enter filename, or Enter to "
e69f : 6c6f6164206672.. 		db	"load from console: ",0
                        ;
e6b3 : 209feb           		jsr	getFileName	;get filename
e6b6 : ad8ddf           		lda	filename	;null?
e6b9 : d006             		bne	loaddiskfile
e6bb : 2009e7           		jsr	loadHexConsole	;load from console
e6be : 4ccde6           		jmp	loadCheckAuto	;check auto-run
                        ;
                        ; Open the file
                        ;
e6c1 : a08d             loaddiskfile	ldy	#filename&$ff
e6c3 : a2df             		ldx	#filename/256
e6c5 : a9ff             		lda	#$ff
e6c7 : 8df917           		sta	ID		;print dots
e6ca : 20dae6           		jsr	loadHexFile
                        ;
                        ; If the auto-run vector is no longer $ffff, then jump
                        ; to whatever it points to.
                        ;
AS65 Assembler for R6502 [1.42].                                     Page   20
---------------------------------- xKIM.asm ----------------------------------

e6cd : adf9df           loadCheckAuto	lda	AutoRun+1
e6d0 : c9ff             		cmp	#$ff		;unchanged?
e6d2 : f003             		beq	lExit11
e6d4 : 6cf8df           		jmp	(AutoRun)	;execute!
e6d7 : 4c40e1           lExit11		jmp	extKimLoop
                        ;
                        ;=====================================================
                        ; This subroutine loads a hex file from the SD.  On
                        ; entry the pointer to the filename is in X (MSB) and
                        ; Y (LSB).
                        ;
e6da : a9ff             loadHexFile	lda	#$ff
e6dc : 8df9df           		sta	AutoRun+1
e6df : 8df917           		sta	ID		;we want dots
e6e2 : 204ded           		jsr	DiskOpenRead
e6e5 : 901c             		bcc	loadHexOk	;opened ok
                        ;
e6e7 : 20d1ea           openfail	jsr	putsil
e6ea : 0d0a             		db	CR,LF
e6ec : 4661696c656420.. 		db	"Failed to open file"
e6ff : 0d0a00           		db	CR,LF,0
e702 : 60               		rts
                        ;
e703 : 2002ec           loadHexOk	jsr	setInputFile	;redirect input
e706 : 4c41e7           		jmp	loadStart
                        ;
                        ;=====================================================
                        ; This subroutine is called to load a hex file from
                        ; the console.
                        ;
e709 : a9ff             loadHexConsole	lda	#$ff
e70b : 8df9df           		sta	AutoRun+1
e70e : a900             		lda	#0
e710 : 8df917           		sta	ID		;don't print dots
e713 : 20d1ea           		jsr	putsil
e716 : 0d0a             		db	CR,LF
e718 : 57616974696e67.. 		db	"Waiting for file, or ESC to"
e733 : 20657869742e2e2e 		db	" exit..."
e73b : 0d0a00           		db	CR,LF,0
e73e : 20f7eb           		jsr	setInputConsole
                        ;
                        ; The start of a line.  First character should be a
                        ; colon, but toss out CRs, LFs, etc.  Anything else
                        ; causes an abort.
                        ;
e741 : 20f4eb           loadStart	jsr	redirectedGetch	;get start of line
e744 : c90d             		cmp	#CR
e746 : f0f9             		beq	loadStart
e748 : c90a             		cmp	#LF
e74a : f0f5             		beq	loadStart
e74c : c93a             		cmp	#':'		;what we expect
e74e : d05a             		bne	loadAbortB
                        ;
                        ; Get the header of the record
                        ;
e750 : a900             		lda	#0
e752 : 8de717           		sta	CHKL		;initialize checksum
                        ;
e755 : 2000eb           		jsr	getHex		;get byte count
e758 : b054             		bcs	loadAbortC
e75a : 8d81df           		sta	byteCount	;save byte count
e75d : 2044e9           		jsr	updateCrc
AS65 Assembler for R6502 [1.42].                                     Page   21
---------------------------------- xKIM.asm ----------------------------------

e760 : 2000eb           		jsr	getHex		;get the MSB of offset
e763 : b04d             		bcs	loadAbortD
e765 : 85fb             		sta	POINTH
e767 : 2044e9           		jsr	updateCrc
e76a : 2000eb           		jsr	getHex		;get LSB of offset
e76d : b047             		bcs	loadAbortE
e76f : 85fa             		sta	POINTL
e771 : 2044e9           		jsr	updateCrc
e774 : 2000eb           		jsr	getHex		;get the record type
e777 : b041             		bcs	loadAbortF
e779 : 2044e9           		jsr	updateCrc
                        ;
                        ; Only handle two record types:
                        ;    00 = data record
                        ;    01 = end of file record
                        ;
e77c : c900             		cmp	#DATA_RECORD
e77e : f05d             		beq	loadDataRec
e780 : c901             		cmp	#EOF_RECORD
e782 : f042             		beq	loadEof
                        ;
                        ; Unknown record type
                        ;
e784 : a941             		lda	#'A'		;reason
                        ;
                        ; This is the common error handler for various reasons
                        ; On entry A contains an ASCII character which is outp
                        ; to indicate the specific error reason.
                        ;
e786 : 48               loadAbort       pha			;save reason
e787 : 20d1ea           		jsr	putsil
e78a : 0d0a             		db	CR,LF
e78c : 41626f7274696e.. 		db	"Aborting, reason: "
e79e : 00               		db	0
e79f : 68               		pla			;restore and...
e7a0 : 20a01e           		jsr	OUTCH		;...display reason
e7a3 : 202f1e           		jsr	CRLF
e7a6 : 20f7eb           loadExit	jsr	setInputConsole
e7a9 : 60               		rts
                        ;
                        ; Various error reason codes.  This was meant to be
                        ; very temporary as I worked out the real problem, but
                        ; this debug code immediately "solved" the problem so
                        ; I just left these as-is until the root cause is
                        ; discovered.
                        ;
e7aa : a942             loadAbortB	lda	#'B'
e7ac : d0d8             		bne	loadAbort
                        ;
e7ae : a943             loadAbortC	lda	#'C'
e7b0 : d0d4             		bne	loadAbort
                        ;
e7b2 : a944             loadAbortD	lda	#'D'
e7b4 : d0d0             		bne	loadAbort
                        ;
e7b6 : a945             loadAbortE	lda	#'E'
e7b8 : d0cc             		bne	loadAbort
                        ;
e7ba : a946             loadAbortF	lda	#'F'
e7bc : d0c8             		bne	loadAbort
                        ;
e7be : a947             loadAbortG	lda	#'G'
AS65 Assembler for R6502 [1.42].                                     Page   22
---------------------------------- xKIM.asm ----------------------------------

e7c0 : d0c4             		bne	loadAbort
                        ;
e7c2 : a948             loadAbortH	lda	#'H'
e7c4 : d0c0             		bne	loadAbort
                        ;
                        ; EOF is easy
                        ;
e7c6 : 2000eb           loadEof		jsr	getHex		;get checksum
e7c9 : 20f7eb           		jsr	setInputConsole	;reset input vector
e7cc : 20d1ea           		jsr	putsil
e7cf : 0d0a             		db	CR,LF
e7d1 : 5375636365737321 		db	"Success!"
e7d9 : 0d0a00           		db	CR,LF,0
e7dc : 60               		rts
                        ;
                        ; Data records have more work.  After processing the
                        ; line, print a dot to indicate progress.  This should
                        ; be re-thought as it could slow down loading a really
                        ; big file if the console speed is slow.
                        ;
e7dd : ae81df           loadDataRec	ldx	byteCount	;byte count
e7e0 : a000             		ldy	#0		;offset
e7e2 : 8e81df           loadData1	stx	byteCount
e7e5 : 8c82df           		sty	saveY
e7e8 : 2000eb           		jsr	getHex
e7eb : b0d1             		bcs	loadAbortG
e7ed : 2044e9           		jsr	updateCrc
e7f0 : ac82df           		ldy	saveY
e7f3 : ae81df           		ldx	byteCount
e7f6 : 91fa             		sta	(POINTL),y
e7f8 : c8               		iny
e7f9 : ca               		dex
e7fa : d0e6             		bne	loadData1
                        ;
                        ; All the bytes were read so get the checksum and see
                        ; if it agrees.  The checksum is a twos-complement, so
                        ; just add the checksum into what we've been calculati
                        ; and if the result is zero then the record is good.
                        ;
e7fc : 2000eb           		jsr	getHex		;get checksum
e7ff : 18               		clc
e800 : 6de717           		adc	CHKL
e803 : d0bd             		bne	loadAbortH	;non-zero is error
                        ;
                        ; If loading from an SD file then print a dot at the
                        ; end of each record.  Doing this for serial input is
                        ; very bad because the terminal program is sending the
                        ; next character while this is sending the dot.  Ie,
                        ; data is lost.
                        ;
e805 : adf917           		lda	ID
e808 : f005             		beq	lrecdone	;jump if not file
e80a : a92e             		lda	#'.'		;sanity indicator when
e80c : 20a01e           		jsr	OUTCH		;...loading from file
e80f : 4c41e7           lrecdone	jmp	loadStart
e812 : 4c40e1           lExit1		jmp	extKimLoop
                        ;
                        ;=====================================================
                        ; Handles the command to save a region of memory as a
                        ; file on the SD.
                        ;
e815 : 205ceb           saveHex		jsr	getAddrRange	;get range to dump
AS65 Assembler for R6502 [1.42].                                     Page   23
---------------------------------- xKIM.asm ----------------------------------

e818 : b0f8             		bcs	lExit1	;abort on error
                        ;
                        ; Get the filename to save to
                        ;
e81a : 20d1ea           		jsr	putsil
e81d : 0d0a             		db	CR,LF
e81f : 456e7465722066.. 		db	"Enter filename, or Enter to "
e83b : 646973706c6179.. 		db	"display to console: ",0
                        ;
e850 : 209feb           		jsr	getFileName	;get filename
e853 : ad8ddf           		lda	filename	;null?
e856 : f012             		beq	saveHexConsole	;dump to console
                        ;
                        ; They selected a file, so try to open it.
                        ;
e858 : a2df             		ldx	#filename>>8
e85a : a08d             		ldy	#filename&$ff
e85c : 2079ed           		jsr	DiskOpenWrite	;attempt to open file
e85f : 9003             		bcc	sopenok		;branch if opened ok
e861 : 4ce7e6           		jmp	openfail
                        ;
e864 : 204cec           sopenok		jsr	setOutputFile
e867 : 4c6de8           		jmp	savehex2
                        ;
                        ; They are saving to the console.  Set up the output
                        ; vector and do the job.
                        ;
e86a : 2041ec           saveHexConsole	jsr	setOutputConsole
                        ;
                        ; Compute the number of bytes to dump
                        ;
e86d : 38               savehex2	sec
e86e : adf717           		lda	EAL
e871 : edf517           		sbc	SAL
e874 : 8ddcdf           		sta	Temp16L
e877 : adf817           		lda	EAH
e87a : edf617           		sbc	SAH
e87d : 8ddddf           		sta	Temp16H
e880 : 9042             		bcc	SDone	;start > end
e882 : 0900             		ora	#0
e884 : 303e             		bmi	SDone	;more than 32K seems wrong
                        ;
                        ; Add one to the count
                        ;
e886 : eedcdf           		inc	Temp16L
e889 : d003             		bne	slab1
e88b : eedddf           		inc	Temp16H
                        ;
                        ; Move pointer to zero page
                        ;
e88e : adf517           slab1		lda	SAL
e891 : 85fa             		sta	POINTL
e893 : adf617           		lda	SAH
e896 : 85fb             		sta	POINTH
                        ;
                        ; Top of each loop.  Start by seeing if there are any 
                        ; left to dump.
                        ;
e898 : addddf           Sloop1		lda	Temp16H
e89b : d02a             		bne	Sgo	;more to do
e89d : addcdf           		lda	Temp16L
e8a0 : d025             		bne	Sgo	;more to do
AS65 Assembler for R6502 [1.42].                                     Page   24
---------------------------------- xKIM.asm ----------------------------------

                        ;
                        ; At end of the region, so output an end record.  This
                        ; probably looks like overkill but keep in mind this
                        ; might be going to a file so we can't use the normal
                        ; string put functions.
                        ;
e8a2 : a93a             		lda	#':'
e8a4 : 202fec           		jsr	redirectedOutch
e8a7 : a900             		lda	#0
e8a9 : 2015ec           		jsr	HexToOutput
e8ac : 2015ec           		jsr	HexToOutput
e8af : 2015ec           		jsr	HexToOutput
e8b2 : a901             		lda	#1
e8b4 : 2015ec           		jsr	HexToOutput
e8b7 : a9ff             		lda	#$ff
e8b9 : 2015ec           		jsr	HexToOutput
                        ;
                        ; If output to file, flush and close the file.
                        ;
e8bc : ad8ddf           		lda	filename
e8bf : f003             		beq	SDone		;it's going to console
e8c1 : 2032ec           		jsr	CloseOutFile
e8c4 : 4c40e1           SDone		jmp	extKimLoop	;back to the monitor
                        ;
                        ; This dumps the next line.  See how many bytes are le
                        ; and if more than BYTESLINE, then just do BYTESLINE.
                        ;
e8c7 : addddf           Sgo		lda	Temp16H
e8ca : d007             		bne	Sdef	;do default number of bytes
e8cc : addcdf           		lda	Temp16L
e8cf : c910             		cmp	#BYTESLINE
e8d1 : 9002             		bcc	Scnt	;more than max per line
e8d3 : a910             Sdef		lda	#BYTESLINE
e8d5 : 8de917           Scnt		sta	SAVX	;for decrementing
e8d8 : 8df917           		sta	ID	;for subtracting
                        ;
                        ; Put out the header
                        ;
e8db : a93a             		lda	#':'
e8dd : 202fec           		jsr	redirectedOutch
                        ;
e8e0 : ade917           		lda	SAVX
e8e3 : 8de717           		sta	CHKL	;start checksum
e8e6 : 2015ec           		jsr	HexToOutput
                        ;
e8e9 : a5fb             		lda	POINTH	;starting address
e8eb : 2044e9           		jsr	updateCrc
e8ee : 2015ec           		jsr	HexToOutput
e8f1 : a5fa             		lda	POINTL
e8f3 : 2044e9           		jsr	updateCrc
e8f6 : 2015ec           		jsr	HexToOutput
                        ;
e8f9 : a900             		lda	#0	;record type - data
e8fb : 2015ec           		jsr	HexToOutput
                        ;
                        ; Now print the proper number of bytes
                        ;
e8fe : a000             Sloop2		ldy	#0
e900 : b1fa             		lda	(POINTL),y	;get byte
e902 : 2044e9           		jsr	updateCrc
e905 : 2015ec           		jsr	HexToOutput
e908 : 20631f           		jsr	INCPT	;increment pointer
AS65 Assembler for R6502 [1.42].                                     Page   25
---------------------------------- xKIM.asm ----------------------------------

                        ;
e90b : cee917           sdec		dec	SAVX
e90e : d0ee             		bne	Sloop2
                        ;
                        ; Now print checksum
                        ;
e910 : ade717           		lda	CHKL
e913 : 49ff             		eor	#$ff	;one's complement
e915 : 18               		clc
e916 : 6901             		adc	#1	;two's complement
e918 : 2015ec           		jsr	HexToOutput
                        ;
                        ; Output a CR/LF
                        ;
e91b : a90d             		lda	#CR
e91d : 202fec           		jsr	redirectedOutch
e920 : a90a             		lda	#LF
e922 : 202fec           		jsr	redirectedOutch
                        ;
                        ; If saving to disk, output a dot to indicate progress
                        ;
e925 : ad8ddf           		lda	filename
e928 : f005             		beq	shf2
                        ;
e92a : a92e             		lda	#'.'
e92c : 20a01e           		jsr	OUTCH	;goes to console
                        ;
e92f : 38               shf2		sec
e930 : addcdf           		lda	Temp16L
e933 : edf917           		sbc	ID
e936 : 8ddcdf           		sta	Temp16L
e939 : addddf           		lda	Temp16H
e93c : e900             		sbc	#0
e93e : 8ddddf           		sta	Temp16H
                        ;
e941 : 4c98e8           		jmp	Sloop1
                        ;
                        ;=====================================================
                        ; Adds the character in A to the CRC.  Preserves A.
                        ;
e944 : 48               updateCrc	pha
e945 : 18               		clc
e946 : 6de717           		adc	CHKL
e949 : 8de717           		sta	CHKL
e94c : 68               		pla
e94d : 60               		rts
                        ;
                        ;=====================================================
                        ; Handles the command to prompt for an address and the
                        ; jump to it.
                        ;
e94e : 20ceea           jumpAddress     jsr	space
e951 : 2038eb           		jsr	getStartAddr
e954 : b006             		bcs	cmdRet	;branch on bad address
e956 : 202f1e           		jsr	CRLF
e959 : 6cf517           		jmp	(SAL)	;else jump to address
                        ;
e95c : 4c40e1           cmdRet		jmp	extKimLoop
                        ;
                        ;=====================================================
                        ; Ping the Arduno disk controller.  This just sends th
                        ; PING command gets back one character, then returns.
AS65 Assembler for R6502 [1.42].                                     Page   26
---------------------------------- xKIM.asm ----------------------------------

                        ; Not much of a test but is sufficient to prove the
                        ; link is working.
                        ;
e95f :                  pingDisk
                        ;		jsr	xParInit	;init interface
e95f : 20d1ea           		jsr	putsil
e962 : 696e672e2e2e2000 		db	"ing... ",0
e96a : 20ffec           		jsr	DiskPing
e96d : 20d1ea           		jsr	putsil
e970 : 7375636365737321 		db	"success!"
e978 : 0d0a00           		db	CR,LF,0
e97b : 4c40e1           		jmp	extKimLoop
                        ;
                        ;=====================================================
                        ; Do a disk directory of the SD card.
                        ;
e97e : 20d1ea           doDiskDir	jsr	putsil
e981 : 69736b20446972.. 		db	"isk Directory..."
e991 : 0d0a00           		db	CR,LF,0
e994 : 209be9           		jsr	doSDDiskDir
e997 : 4c40e1           		jmp	extKimLoop
e99a : 60               doDiskDirEnd	rts
                        ;
                        ;=====================================================
                        ; Subroutine to do a disk directory.  Prints filenames
                        ; to the console.
                        ;
e99b : 2078ec           doSDDiskDir	jsr	xParInit
e99e : 2012ed           		jsr	DiskDir
                        ;
                        ; Get/Display each entry
                        ;
e9a1 : a2df             doDiskDirLoop   ldx	#filename/256	;pointer to buffer
e9a3 : a08d             		ldy	#filename&$ff
e9a5 : 86f9             		stx	INH		;save for puts
e9a7 : 84f8             		sty	INL
e9a9 : 201ced           		jsr	DiskDirNext	;get next entry
e9ac : b0ec             		bcs	doDiskDirEnd	;carry = end of list
e9ae : 20c8ea           		jsr	space3
e9b1 : 20e5ea           		jsr	puts		;else print name
e9b4 : 202f1e           		jsr	CRLF
e9b7 : 4ca1e9           		jmp	doDiskDirLoop	;do next entry
                        ;
                        ;=====================================================
                        ; Type the contents of an SD file to console.
                        ;
e9ba : 20d1ea           typeFile	jsr	putsil
e9bd : 202d20456e7465.. 		db	" - Enter filename: ",0
e9d1 : 209feb           		jsr	getFileName
e9d4 : a08d             		ldy	#filename&$ff
e9d6 : a2df             		ldx	#filename/256
                        ;		jsr	xParInit
e9d8 : 204ded           		jsr	DiskOpenRead
e9db : 901e             		bcc	typeFile1	;opened ok
                        ;
e9dd : 20d1ea           		jsr	putsil
e9e0 : 0d0a             		db	CR,LF
e9e2 : 4661696c656420.. 		db	"Failed to open file"
e9f5 : 0d0a00           		db	CR,LF,0
e9f8 : 4c40e1           		jmp	extKimLoop
                        ;
                        ; Now just keep reading in bytes and displaying them.
AS65 Assembler for R6502 [1.42].                                     Page   27
---------------------------------- xKIM.asm ----------------------------------

                        ;
e9fb : 2002ec           typeFile1	jsr	setInputFile	;reading from file
e9fe : 20c5eb           typeFileLoop	jsr	getNextFileByte
ea01 : b006             		bcs	typeEof
ea03 : 20a01e           		jsr	OUTCH	;display character
ea06 : 4cfee9           		jmp	typeFileLoop
                        ;
ea09 : 20e7ed           typeEof		jsr	DiskClose
ea0c : 4c40e1           		jmp	extKimLoop
                        ;
                        ;=====================================================
                        ; Calculate the offset for a relative branch.  6502
                        ; relative branch calculations are well known.
                        ;
                        ; Offset from branch (BASE) = TARGET - (BASE+2).
                        ; If the result is positive, upper byte must be
                        ; zero.  If negative, upper byte must be FF.
                        ;
                        ; BASE	TARGET	Computed	Actual
                        ; 0200	0200	0200-(0200+2)	FFFE
                        ; 0200	020E	020E-(0200+2)	000C
                        ; 0226	0220	0220-(0226+2)	FFF8
                        ; 0156	015A	015A-(0156+2)	0002
                        ; 015C	012D	012D-(015C+2)	FFCF
                        ; 0200	0300	0300-(0200+2)	00FE - out of range
                        ; 0300	0200	0200-(0300+2)	FEFE - out of range
                        ;
ea0f : 20d1ea           offCalc		jsr	putsil
ea12 : 202d204272616e.. 		db	" - Branch instruction address: "
ea31 : 00               		db	0
ea32 : 2038eb           		jsr	getStartAddr
ea35 : b030             		bcs	calcExit
ea37 : 20d1ea           		jsr	putsil
ea3a : 2c206272616e63.. 		db	", branch to: "
ea47 : 00               		db	0
ea48 : 204aeb           		jsr	getEndAddr
ea4b : b01a             		bcs	calcExit
ea4d : 206deb           		jsr	ComputeOffset	;does the work
ea50 : 9018             		bcc	relgood		;if good offset
                        ;
                        ; Branch is out of range.
                        ;
ea52 : 20d1ea           		jsr	putsil
ea55 : 202d206f757420.. 		db	" - out of range",CR,LF,0
ea67 : 4c40e1           calcExit	jmp	extKimLoop
                        ;
                        ; Branch is in range so dislay the value.
                        ;
ea6a : 48               relgood		pha			;save offset
ea6b : 20d1ea           		jsr	putsil
ea6e : 204f6666736574.. 		db	" Offset: ",0
ea78 : 68               		pla
ea79 : 203b1e           		jsr	PRTBYT
ea7c : 4c40e1           		jmp	extKimLoop
                        ;
                        ; Add new commands here...
                        ;
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   28
---------------------------------- xKIM.asm ----------------------------------

                        ;
                        ;=====================================================
                        ; This subroutine will search for a command in a table
                        ; and call the appropriate handler.  See the command
                        ; table near the start of the code for what the format
                        ; is.  If a match is found, pop off the return address
                        ; from the stack and jump to the code.  Else, return.
                        ;
ea7f : a000             searchCmd	ldy	#0
ea81 : b1fa             cmdLoop		lda	(POINTL),y
ea83 : f01c             		beq	cmdNotFound
ea85 : c5f3             		cmp	ACC	;compare to user's input
ea87 : f007             		beq	cmdMatch
ea89 : c8               		iny		;start of function ptr
ea8a : c8               		iny
ea8b : c8               		iny		;start of help
ea8c : c8               		iny
ea8d : c8               		iny		;move to next command
ea8e : d0f1             		bne	cmdLoop
                        ;
                        ; It's found!  Load up the address of the code to call
                        ; pop the return address off the stack and jump to the
                        ; handler.
                        ;
ea90 : c8               cmdMatch	iny
ea91 : b1fa             		lda	(POINTL),y	;handler LSB
ea93 : 48               		pha
ea94 : c8               		iny
ea95 : b1fa             		lda	(POINTL),y	;handler MSB
ea97 : 85fb             		sta	POINTH
ea99 : 68               		pla
ea9a : 85fa             		sta	POINTL
ea9c : 68               		pla		;pop return address
ea9d : 68               		pla
ea9e : 6cfa00           		jmp	(POINTL)
                        ;
                        ; Not found, so just return.
                        ;
eaa1 : 60               cmdNotFound	rts
                        ;
                        ;=====================================================
                        ; Given a pointer to a command table in POINT, display
                        ; the help text for all commands in the table.
                        ;
eaa2 : a000             displayHelp	ldy	#0	;index into command table
eaa4 : b1fa             showHelpLoop	lda	(POINTL),y	;get command
eaa6 : f01f             		beq	showHelpDone	;jump if at end
                        ;
                        ; Display this entry's descriptive text
                        ;
eaa8 : c8               		iny		;skip over command
eaa9 : c8               		iny		;skip over function ptr
eaaa : c8               		iny
eaab : b1fa             		lda	(POINTL),y
eaad : 85f8             		sta	INL
eaaf : c8               		iny
eab0 : b1fa             		lda	(POINTL),y
eab2 : 85f9             		sta	INH
eab4 : 98               		tya
eab5 : 48               		pha
eab6 : 209e1e           		jsr	OUTSP
eab9 : 209e1e           		jsr	OUTSP
AS65 Assembler for R6502 [1.42].                                     Page   29
---------------------------------- xKIM.asm ----------------------------------

eabc : 20e5ea           		jsr	puts	;print description
eabf : 202f1e           		jsr	CRLF
eac2 : 68               		pla
eac3 : a8               		tay
eac4 : c8               		iny		;point to next entry
eac5 : d0dd             		bne	showHelpLoop
eac7 : 60               showHelpDone	rts
                        ;
                        ;=====================================================
                        ; Print some spaces.
                        ;
eac8 : 20ceea           space3		jsr	space
eacb : 20ceea           space2		jsr	space
eace : 4c9e1e           space   	jmp	OUTSP
                        ;
                        ;=====================================================
                        ; This prints the null-terminated string that
                        ; immediately follows the JSR to this function.  This
                        ; version was written by Ross Archer and is at:
                        ;
                        ;    www.6502.org/source/io/primm.htm
                        ;
ead1 : 68               putsil		pla
ead2 : 85f8             		sta	INL
ead4 : 68               		pla
ead5 : 85f9             		sta	INH
ead7 : a001             		ldy	#1
ead9 : 20e7ea           		jsr	putsy
eadc : e6f8             		inc	INL
eade : d002             		bne	puts2
eae0 : e6f9             		inc	INH
eae2 : 6cf800           puts2		jmp	(INL)
                        ;
                        ;=====================================================
                        ; This prints the null terminated string pointed to by
                        ; INL and INH.  Modifies those locations to point to
                        ; the end of the string.
                        ;
eae5 : a000             puts		ldy	#0
eae7 : b1f8             putsy		lda	(INL),y
eae9 : e6f8             		inc	INL
eaeb : d002             		bne	puts1
eaed : e6f9             		inc	INH
eaef : 0900             puts1		ora	#0
eaf1 : f00c             		beq	putsdone
eaf3 : 8c82df           		sty	saveY
eaf6 : 20a01e           		jsr	OUTCH	;print character
eaf9 : ac82df           		ldy	saveY
eafc : 4ce7ea           		jmp	putsy
eaff : 60               putsdone	rts
                        ;
                        ;=====================================================
                        ; This gets two hex characters and returns the value
                        ; in A with carry clear.  If a non-hex digit is
                        ; entered, then A contans the offending character and
                        ; carry is set.
                        ;
eb00 : 2016eb           getHex		jsr	getNibble
eb03 : b01e             		bcs	getNibBad
eb05 : 0a               		asl	a
eb06 : 0a               		asl	a
eb07 : 0a               		asl	a
AS65 Assembler for R6502 [1.42].                                     Page   30
---------------------------------- xKIM.asm ----------------------------------

eb08 : 0a               		asl	a
eb09 : 8d80df           		sta	saveA
eb0c : 2016eb           		jsr	getNibble
eb0f : b012             		bcs	getNibBad
eb11 : 0d80df           		ora	saveA
eb14 : 18               		clc
eb15 : 60               		rts
                        ;
                        ; Helper.  Gets next input char and converts to a
                        ; value from 0-F in A and returns C clear.  If not a
                        ; valid hex character, return C set.
                        ;
eb16 : 20f4eb           getNibble	jsr	redirectedGetch
eb19 : a20f             		ldx	#nibbleHexEnd-nibbleHex-1
eb1b : dd28eb           getNibble1	cmp	nibbleHex,x
eb1e : f005             		beq	getNibF	;got match
eb20 : ca               		dex
eb21 : 10f8             		bpl	getNibble1
eb23 : 38               getNibBad	sec
eb24 : 60               		rts
                        
eb25 : 8a               getNibF		txa		;index is value
eb26 : 18               		clc
eb27 : 60               		rts
                        ;
eb28 : 30313233343536.. nibbleHex	db	"0123456789ABCDEF"
eb38 =                  nibbleHexEnd	equ	*
                        ;
                        ;=====================================================
                        ; Gets a four digit hex address amd places it in
                        ; SAL and SAH.  Returns C clear if all is well, or C
                        ; set on error and A contains the character.
                        ;
eb38 : 2000eb           getStartAddr	jsr	getHex
eb3b : b00c             		bcs	getDone
eb3d : 8df617           		sta	SAH
eb40 : 2000eb           		jsr	getHex
eb43 : b004             		bcs	getDone
eb45 : 8df517           		sta	SAL
eb48 : 18               		clc
eb49 : 60               getDone		rts
                        ;
                        ;=====================================================
                        ; Gets a four digit hex address amd places it in
                        ; EAL and EAH.  Returns C clear if all is well, or C
                        ; set on error and A contains the character.
                        ;
eb4a : 2000eb           getEndAddr	jsr	getHex
eb4d : b0fa             		bcs	getDone
eb4f : 8df817           		sta	EAH
eb52 : 2000eb           		jsr	getHex
eb55 : b0f2             		bcs	getDone
eb57 : 8df717           		sta	EAL
eb5a : 18               		clc
eb5b : 60               		rts
                        ;
                        ;=====================================================
                        ; Get an address range and leave them in SAL and EAL.
                        ;
eb5c : 20ceea           getAddrRange    jsr	space
eb5f : 2038eb           		jsr	getStartAddr
eb62 : b0e5             		bcs	getDone
AS65 Assembler for R6502 [1.42].                                     Page   31
---------------------------------- xKIM.asm ----------------------------------

eb64 : a92d             		lda	#'-'
eb66 : 20a01e           		jsr	OUTCH
eb69 : 204aeb           		jsr	getEndAddr
eb6c : 60               		rts
                        ;
                        ;=====================================================
                        ; This computes the relative offset between the
                        ; address in SAL/SAH (address of branch instruction)
                        ; and EAL/EAH (address to jump to).  If a valid range,
                        ; returns C clear and the offset in A.  If the branch
                        ; is out of range, C is set and A undefined.  Modifies
                        ; A, SAL and SAH.
                        ;
eb6d :                  ComputeOffset
                        ;
                        ; Add two to the end (BASE) address.  For calculations
                        ;   BASE = SAL/SAH
                        ;   TARGET = EAL/EAH
                        ;
eb6d : 18               		clc
eb6e : adf517           		lda	SAL
eb71 : 6902             		adc	#2
eb73 : 8df517           		sta	SAL
eb76 : 9003             		bcc	coffsub
eb78 : eef617           		inc	SAH
                        ;
                        ; Subtract the BASE (end) address from the TARGET (sta
                        ;
eb7b : 38               coffsub		sec
eb7c : adf717           		lda	EAL
eb7f : edf517           		sbc	SAL
eb82 : 48               		pha		;save for later
eb83 : 8df517           		sta	SAL
eb86 : adf817           		lda	EAH
eb89 : edf617           		sbc	SAH
eb8c : 8df617           		sta	SAH	;SAL/SAH contain offset
                        ;
                        ; High part must be either FF for negative branch or
                        ; 00 for a positive branch.  Cheat a bit here by rolli
                        ; the MSBit into C and adding to the MSByte.  If the
                        ; result is zero then everything is cool.
                        ;
eb8f : 68               		pla		;restore LSB of offset
eb90 : 48               		pha
eb91 : 0a               		asl	a	;put sign into C
eb92 : adf617           		lda	SAH
eb95 : 6900             		adc	#0
eb97 : f003             		beq	cogood	;branch if in range
                        ;
eb99 : 68               		pla		;clean up stack
eb9a : 38               		sec		;error
eb9b : 60               		rts
                        ;
eb9c : 68               cogood		pla		;get back offset
eb9d : 18               		clc
eb9e : 60               		rts
                        ;
                        ;=====================================================
                        ; Get a disk filename.  The KIM's behavior of echoing
                        ; every key prevents this from being too fancy, but it
                        ; good enough.
                        ;
AS65 Assembler for R6502 [1.42].                                     Page   32
---------------------------------- xKIM.asm ----------------------------------

eb9f : a200             getFileName	ldx	#0
eba1 : 205a1e           getFilename1	jsr	GETCH	;get next key
eba4 : c90d             		cmp	#CR	;end of the input?
eba6 : f014             		beq	getFnDone
eba8 : c908             		cmp	#BS	;backspace?
ebaa : f00a             		beq	getFnDel
ebac : e00c             		cpx	#FILENAME_SIZE	;check size
ebae : f0f1             		beq	getFilename1	;at length limit
ebb0 : 9d8ddf           		sta	filename,x	;else save it
ebb3 : e8               		inx
ebb4 : d0eb             		bne	getFilename1
                        ;
ebb6 : ca               getFnDel	dex		;back up one
ebb7 : 10e8             		bpl	getFilename1
ebb9 : e8               		inx		;can't go past start
ebba : f0e5             		beq	getFilename1
ebbc : a900             getFnDone       lda	#0	;terminate line
ebbe : 9d8ddf           		sta	filename,x
ebc1 : 202f1e           		jsr	CRLF
ebc4 : 60               		rts
                        ;
                        ;=====================================================
                        ; This gets the next byte from an open disk file.  If
                        ; there are no more bytes left, this returns C set.
                        ; Else, C is clear and A contains the character.
                        ;
ebc5 : aedadf           getNextFileByte ldx 	diskBufOffset
ebc8 : ecdbdf           		cpx	diskBufLength
ebcb : d014             		bne	hasdata		;branch if still data
                        ;
                        ; There is no data left in the buffer, so read a
                        ; block from the SD system.
                        ;
ebcd : a940             		lda	#BUFFER_SIZE
ebcf : a2df             		ldx	#buffer>>8
ebd1 : a09a             		ldy	#buffer&$ff
ebd3 : 207eed           		jsr	DiskRead
ebd6 : b012             		bcs	getNextEof
                        ;
                        ; A contains the number of bytes actually read.
                        ;
ebd8 : 8ddbdf           		sta	diskBufLength	;save length
ebdb : c900             		cmp	#0		;shouldn't happen
ebdd : f00b             		beq	getNextEof
                        ;
ebdf : a200             		ldx	#0
ebe1 : bd9adf           hasdata		lda	buffer,x
ebe4 : e8               		inx
ebe5 : 8edadf           		stx	diskBufOffset
ebe8 : 18               		clc
ebe9 : 60               		rts
                        ;
ebea : a900             getNextEof	lda	#0
ebec : 8ddadf           		sta	diskBufOffset
ebef : 8ddbdf           		sta	diskBufLength
ebf2 : 38               		sec
ebf3 : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   33
---------------------------------- xKIM.asm ----------------------------------

                        ;
                        ;=====================================================
                        ; This is a helper function used for redirected I/O.
                        ; It simply does a jump through the input vector
                        ; pointer to get the next input character.
                        ;
ebf4 : 6c89df           redirectedGetch	jmp	(inputVector)
                        ;
                        ;=====================================================
                        ; Set up the input vector to point to the normal
                        ; console input subroutine.
                        ;
ebf7 : a95a             setInputConsole	lda	#GETCH&$ff
ebf9 : 8d89df           		sta     inputVector
ebfc : a91e             		lda	#GETCH/256
ebfe : 8d8adf           		sta	inputVector+1
ec01 : 60               		rts
                        ;
                        ;=====================================================
                        ; Set up the input vector to point to a file read
                        ; subroutine.
                        ;
ec02 : a9c5             setInputFile    lda	#getNextFileByte&$ff
ec04 : 8d89df           		sta     inputVector
ec07 : a9eb             		lda	#getNextFileByte/256
ec09 : 8d8adf           		sta	inputVector+1
                        ;
                        ; Clear counts and offsets so the next read will
                        ; cause the file to be read.
                        ;
ec0c : a900             		lda	#0
ec0e : 8ddadf           		sta	diskBufOffset
ec11 : 8ddbdf           		sta	diskBufLength
ec14 : 60               		rts
                        ;
                        ;=====================================================
                        ; Print character in A as two hex digits to the
                        ; current output device (console or file).
                        ;
ec15 : 48               HexToOutput	pha		;save return value
ec16 : 48               		pha
ec17 : 4a               		lsr	a	;move top nibble to bottom
ec18 : 4a               		lsr	a
ec19 : 4a               		lsr	a
ec1a : 4a               		lsr	a
ec1b : 2024ec           		jsr	hexta	;output nibble
ec1e : 68               		pla
ec1f : 2024ec           		jsr	hexta
ec22 : 68               		pla		;restore
ec23 : 60               		rts
                        ;
ec24 : 290f             hexta		and	#%0001111
ec26 : c90a             		cmp	#$0a
ec28 : 18               		clc
ec29 : 3002             		bmi	hexta1
ec2b : 6907             		adc	#7
ec2d : 6930             hexta1		adc	#'0'	;then fall into...
                        ;
                        ;=====================================================
                        ; This is a helper function used for redirected I/O.
                        ; It simply does a jump through the output vector
                        ; pointer to send the character in A to the proper
AS65 Assembler for R6502 [1.42].                                     Page   34
---------------------------------- xKIM.asm ----------------------------------

                        ; device.
                        ;
ec2f : 6c8bdf           redirectedOutch	jmp	(outputVector)
                        ;
                        ;=====================================================
                        ; This flushes any data remaining in the disk buffer
                        ; and then closes the file.
                        ;
ec32 : addadf           CloseOutFile	lda	diskBufOffset
ec35 : f007             		beq	closeonly
ec37 : a2df             		ldx	#buffer>>8
ec39 : a09a             		ldy	#buffer&$ff
ec3b : 20b0ed           		jsr	DiskWrite
                        ;
ec3e : 20e7ed           closeonly	jsr	DiskClose
                        ;
                        ; Fall through...
                        ;
                        ;=====================================================
                        ; Set up the output vector to point to the normal
                        ; console output subroutine.
                        ;
ec41 :                  setOutputConsole
ec41 : a9a0             		lda	#OUTCH&$ff
ec43 : 8d8bdf           		sta     outputVector
ec46 : a91e             		lda	#OUTCH/256
ec48 : 8d8cdf           		sta	outputVector+1
ec4b : 60               		rts
                        ;
                        ;=====================================================
                        ; Set up the output vector to point to a file write
                        ; subroutine.
                        ;
ec4c : a95c             setOutputFile    lda	#putNextFileByte&$ff
ec4e : 8d8bdf           		sta     outputVector
ec51 : a9ec             		lda	#putNextFileByte/256
ec53 : 8d8cdf           		sta	outputVector+1
                        ;
                        ; Clear counts and offsets so the next read will
                        ; cause the file to be read.
                        ;
ec56 : a900             		lda	#0
ec58 : 8ddadf           		sta	diskBufOffset
ec5b : 60               		rts
                        ;
                        ;=====================================================
                        ; Add the byte in A to the output buffer.  If the
                        ; buffer is full, flush it to disk.
                        ;
ec5c : aedadf           putNextFileByte	ldx	diskBufOffset
ec5f : e040             		cpx	#BUFFER_SIZE	;buffer full?
ec61 : d00d             		bne	pNFB		;no
                        ;
                        ; The buffer is full, so write it out.
                        ;
ec63 : 48               		pha			;save byte
ec64 : a940             		lda	#BUFFER_SIZE
ec66 : a2df             		ldx	#buffer>>8
ec68 : a09a             		ldy	#buffer&$ff
ec6a : 20b0ed           		jsr	DiskWrite
                        ;
ec6d : a200             		ldx	#0		;reset index
AS65 Assembler for R6502 [1.42].                                     Page   35
---------------------------------- xKIM.asm ----------------------------------

ec6f : 68               		pla
ec70 : 9d9adf           pNFB		sta	buffer,x
ec73 : e8               		inx
ec74 : 8edadf           		stx	diskBufOffset
ec77 : 60               		rts
                        ;
                        		include	"pario.asm"
                        ;*****************************************************
                        ; These are the low-level I/O routines to talk to the
                        ; Arduino processor connected to the KIM's I/O port.
                        ;
                        ; August 2014, Bob Applegate K2UT, bob@corshamtech.com
                        ;
                        ; Which port bits are used for what:
                        ;
                        ; A0 = Data 0, alternates input/output
                        ; A1 = Data 1, alternates input/output
                        ; A2 = Data 2, alternates input/output
                        ; A3 = Data 3, alternates input/output
                        ; A4 = Data 4, alternates input/output
                        ; A5 = Data 5, alternates input/output
                        ; A6 = Data 6, alternates input/output
                        ; A7 = Data 7, alternates input/output
                        ;
                        ; B0 = Direction bit, always output
                        ; B1 = Write strobe or ACK, always output
                        ; B2 = Read stroke or ACK, always input
                        ;
                        ;----------------------------------------------------
                        ; Bits in the B register
                        ;
0001 =                  DIRECTION	equ	%00000001
0002 =                  PSTROBE		equ	%00000010
0004 =                  ACK		equ	%00000100
                        ;
                        ;----------------------------------------------------
                        ; The KIM has a 6530 with the two I/O ports at $1700.
                        ;
                        ; Addresses of 6530 registers
                        ;
1700 =                  PIABASE		equ	$1700
1700 =                  PIAREGA		equ	PIABASE		;data reg A
1701 =                  PIADDRA		equ	PIABASE+1	;data dir reg A
1702 =                  PIAREGB		equ	PIABASE+2	;data reg B
1703 =                  PIADDRB		equ	PIABASE+3	;data dir reg B
                        		code
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   36
---------------------------------- xKIM.asm ----------------------------------

                        ;*****************************************************
                        ; This is the initialization function.  Call before
                        ; doing anything else with the parallel port.
                        ;
ec78 :                  xParInit
                        ;
                        ; Set up the data direction register for port B so tha
                        ; the DIRECTION and PSTROBE bits are output.  Only tou
                        ; the bits we're using; leave the rest as-is.
                        ;
ec78 : ad0317           		lda	PIADDRB	;get current value
ec7b : 29fb             		and	#~ACK
ec7d : 0903             		ora	#DIRECTION | PSTROBE
ec7f : 8d0317           		sta	PIADDRB
                        ;
ec82 : a9ff             		lda	#$ff
ec84 : 8d0117           		sta	PIADDRA	;set data for write
                        ;
                        ; Now that the data is set, set the direction
                        ; registers.  This prevents weird problems like
                        ; driving lines to the wrong state.
                        ;
ec87 : ad0217           		lda	PIAREGB
ec8a : 29f9             		and	#~(PSTROBE | ACK)
ec8c : 0901             		ora	#DIRECTION
ec8e : 8d0217           		sta	PIAREGB
ec91 : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   37
---------------------------------- xKIM.asm ----------------------------------

                        ;*****************************************************
                        ; This sets up for writing to the Arduino.  Sets up
                        ; direction registers, drives the direction bit, etc.
                        ;
ec92 : a9ff             xParSetWrite    lda	#$ff	;set bits for output
ec94 : 8d0117           		sta	PIADDRA
                        ;
                        ; Set direction flag to output, clear ACK bit
                        ;
ec97 : ad0217           		lda	PIAREGB
ec9a : 29f9             		and	#~(PSTROBE | ACK)
ec9c : 0901             		ora	#DIRECTION
ec9e : 8d0217           		sta	PIAREGB
eca1 : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   38
---------------------------------- xKIM.asm ----------------------------------

                        ;*****************************************************
                        ; This sets up for reading from the Arduino.  Sets up
                        ; direction registers, clears the direction bit, etc.
                        ;
eca2 : a900             xParSetRead     lda	#$00	;set bits for input
eca4 : 8d0117           		sta	PIADDRA
                        ;
                        ; Set direction flag to input, clear ACK bit
                        ;
eca7 : ad0217           		lda	PIAREGB
ecaa : 29f8             		and	#~(DIRECTION | PSTROBE | ACK)
ecac : 8d0217           		sta	PIAREGB
ecaf : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   39
---------------------------------- xKIM.asm ----------------------------------

                        ;*****************************************************
                        ; This writes a single byte to the Arduino.  On entry,
                        ; the byte to write is in A.  This assumes ParSetWrite
                        ; was already called.
                        ;
                        ; Destroys A, all other registers preserved.
                        ;
                        ; Write cycle:
                        ;
                        ;    1. Wait for other side to lower ACK.
                        ;    2. Put data onto the bus.
                        ;    3. Set DIRECTION and PSTROBE to indicate data
                        ;       is valid and ready to read.
                        ;    4. Wait for ACK line to go high, indicating the
                        ;       other side has read the data.
                        ;    5. Lower PSTROBE.
                        ;    6. Wait for ACK to go low, indicating end of
                        ;       transfer.
                        ;
ecb0 : 48               xParWriteByte	pha		;save data
ecb1 : ad0217           Parwl22		lda	PIAREGB	;check status
ecb4 : 2904             		and	#ACK
ecb6 : d0f9             		bne	Parwl22	;wait for ACK to go low
                        ;
                        ; Now put the data onto the bus
                        ;
ecb8 : 68               		pla
ecb9 : 8d0017           		sta	PIAREGA
                        ;
                        ; Raise the strobe so the Arduino knows there is
                        ; new data.
                        ;
ecbc : ad0217           		lda	PIAREGB
ecbf : 0902             		ora	#PSTROBE
ecc1 : 8d0217           		sta	PIAREGB
                        ;
                        ; Wait for ACK to go high, indicating the Arduino has
                        ; pulled the data and is ready for more.
                        ;
ecc4 : ad0217           Parwl33		lda	PIAREGB
ecc7 : 2904             		and	#ACK
ecc9 : f0f9             		beq	Parwl33
                        ;
                        ; Now lower the strobe, then wait for the Arduino to
                        ; lower ACK.
                        ;
eccb : ad0217           		lda	PIAREGB
ecce : 29fd             		and	#~PSTROBE
ecd0 : 8d0217           		sta	PIAREGB
ecd3 : ad0217           Parwl44		lda	PIAREGB
ecd6 : 2904             		and	#ACK
ecd8 : d0f9             		bne	Parwl44
ecda : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   40
---------------------------------- xKIM.asm ----------------------------------

                        ;*****************************************************
                        ; This reads a byte from the Arduino and returns it in
                        ; A.  Assumes ParSetRead was called before.
                        ;
                        ; This does not have a time-out.
                        ;
                        ; Preserves all other registers.
                        ;
                        ; Read cycle:
                        ;
                        ;    1. Wait for other side to raise ACK, indicating
                        ;       data is ready.
                        ;    2. Read data.
                        ;    3. Raise PSTROBE indicating data was read.
                        ;    4. Wait for ACK to go low.
                        ;    5. Lower PSTROBE.
                        ;
ecdb : ad0217           xParReadByte    lda	PIAREGB
ecde : 2904             		and	#ACK	;is their strobe high?
ece0 : f0f9             		beq	xParReadByte	;nope, no data
                        ;
                        ; Data is available, so grab and save it.
                        ;
ece2 : ad0017           		lda	PIAREGA
ece5 : 48               		pha
                        ;
                        ; Now raise our strobe (their ACK), then wait for
                        ; them to lower their strobe.
                        ;
ece6 : ad0217           		lda	PIAREGB
ece9 : 0902             		ora	#PSTROBE
eceb : 8d0217           		sta	PIAREGB
ecee : ad0217           Parrlp1		lda	PIAREGB
ecf1 : 2904             		and	#ACK
ecf3 : d0f9             		bne	Parrlp1	;still active
                        ;
                        ; Lower our ack, then were done.
                        ;
ecf5 : ad0217           		lda	PIAREGB
ecf8 : 29fd             		and	#~PSTROBE
ecfa : 8d0217           		sta	PIAREGB
ecfd : 68               		pla
ecfe : 60               		rts
                        
                        		include	"parproto.inc"
                        ;*****************************************************
                        ; Parallel port protocol
                        ;
                        ; This is the header file for making applications
                        ; compliant with The Remote Disk Protocol Guide which
                        ; is on the Corsham Technologies web page somewhere:
                        ;
                        ;    www.corshamtech.com
                        ;
                        ; This was updated 06/13/2015 to be compliant with the
                        ; official specification, so the opcode values changed
                        ;
                        ; Another update on 02/10/2019
                        ;
                        ;=====================================================
                        ; Commands from host to Arduino
                        ;
AS65 Assembler for R6502 [1.42].                                     Page   41
---------------------------------- xKIM.asm ----------------------------------

0001 =                  PC_GET_VERSION	equ	$01
0005 =                  PC_PING		equ	$05	;ping Arduino
0006 =                  PC_LED_CONTROL	equ	$06	;LED control
0007 =                  PC_GET_CLOCK	equ	$07	;get clock data
0008 =                  PC_SET_CLOCK	equ	$08	;set clock
0010 =                  PC_GET_DIR	equ	$10	;Get directory
0011 =                  PC_GET_MOUNTED	equ	$11	;Get mounted drive list
0012 =                  PC_MOUNT	equ	$12	;Mount drive
0013 =                  PC_UNMOUNT	equ	$13	;Unmount drive
0014 =                  PC_GET_STATUS	equ	$14	;Get status for one drive
0015 =                  PC_DONE		equ	$15	;Stop data
0015 =                  PC_ABORT	equ	PC_DONE
0016 =                  PC_READ_FILE	equ	$16	;Read regular file (non-DSK)
0017 =                  PC_READ_BYTES	equ	$17	;Read sequential bytes
0018 =                  PC_RD_SECTOR	equ	$18	;Read FLEX sector
0019 =                  PC_WR_SECTOR	equ	$19	;Write FLEX sector
001a =                  PC_GET_MAX	equ	$1a	;Get maximum drives
001b =                  PC_WRITE_FILE   equ	$1b	;Open file for writing
001c =                  PC_WRITE_BYTES	equ	$1c	;Data to be written
001d =                  PC_SAVE_CONFIG	equ	$1d	;Save SD.CFG with current value
001e =                  PC_SET_TIMER	equ	$1e	;Set RTC timer
001f =                  PC_RD_SEC_LONG	equ	$1f	;Read sector with long sec num
0020 =                  PC_WR_SEC_LONG	equ	$20	;Write sector with long sec num
                        ;
                        ;=====================================================
                        ; Responses from Arduino to host
                        ;
0081 =                  PR_VERSION_INFO	equ	$81	;Contains version information
0082 =                  PR_ACK		equ	$82	;ACK (no additional information)
0083 =                  PR_NAK		equ	$83	;NAK - one status byte follows
0085 =                  PR_PONG		equ	$85	;Reply to a ping
0087 =                  PR_CLOCK_DATA	equ	$87	;Clock data
0090 =                  PR_DIR_ENTRY	equ	$90	;Directory entry
0091 =                  PR_DIR_END	equ	$91	;End of directory entries
0092 =                  PR_FILE_DATA	equ	$92	;File data
0093 =                  PR_STATUS	equ	$93	;Drive status
0094 =                  PR_SECTOR_DATA	equ	$94	;Sector data
0095 =                  PR_MOUNT_INFO	equ	$95	;Mount entry
0096 =                  PR_MAX_DRIVES	equ	$96	;Maximum number of drives
                        ;
                        ;=====================================================
                        ; Error codes for NAK events.  Yes, these are in
                        ; decimal due to an error in the original
                        ; documentation.
                        ;
0000 =                  ERR_NONE	equ	0
000a =                  ERR_NOT_MOUNTED	equ	10
000b =                  ERR_MOUNTED	equ	11
000c =                  ERR_NOT_FOUND	equ	12
000d =                  ERR_READ_ONLY	equ	13
000e =                  ERR_BAD_DRIVE	equ	14
000f =                  ERR_BAD_TRACK	equ	15
0010 =                  ERR_BAD_SECTOR	equ	16
0011 =                  ERR_READ_ERROR	equ	17
0012 =                  ERR_WRITE_ERROR	equ	18
0013 =                  ERR_NOT_PRESENT	equ	19
0014 =                  ERR_NOT_IMPL	equ	20	;Command not implemented
                        
                        
                        		include	"diskfunc.asm"
                        		list
                        ;=====================================================
AS65 Assembler for R6502 [1.42].                                     Page   42
---------------------------------- xKIM.asm ----------------------------------

                        ; This is a collection of functions for performing
                        ; higher level disk functions.  This hides the nasty
                        ; details of communications with the remote disk
                        ; system.
                        ;
                        ; August 20, 2014 - Bob Applegate
                        ;                   bob@corshamtech.com
                        ;
                        ; 06/14/2015 - Bob Applegate
                        ;		Now that there is an official standard
                        ;		for the protocol between the host (this
                        ;		code) and the DCP (Arduino code), this
                        ;		code has been updated to be compliant.
                        ;
                        ; 01/14/2016 - Bob Applegate
                        ;              Finally converted to 6502.
                        ;
                        ;		include	"parproto.inc"
                        ;
                        ; Number of drives emulated
                        ;
0004 =                  DRIVES		equ	4
                        ;
                        ;=====================================================
                        ; This is a sanity check to verify connectivity to the
                        ; Arduino code is working.  Returns C clear if all is
                        ; good, or C set if not.
                        ;
ecff : 2092ec           DiskPing	jsr	xParSetWrite
ed02 : a905             		lda	#PC_PING	;command
ed04 : 20b0ec           		jsr	xParWriteByte	;send to Arduino
ed07 : 20a2ec           		jsr	xParSetRead
ed0a : 20dbec           		jsr	xParReadByte	;read their reply
ed0d : 2092ec           DiskRetGood	jsr	xParSetWrite
ed10 : 18               		clc			;assume it's good
ed11 : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   43
---------------------------------- xKIM.asm ----------------------------------

                        ;=====================================================
                        ; This starts a directory read of the raw drive, not
                        ; the mounted drive.  No input parameters.  This simpl
                        ; sets up for reading the entries, then the user must
                        ; read each entry.
                        ;
                        ; Returns with C clear on success.  If error, C is set
                        ; and A contains the error code.
                        ;
ed12 : 2092ec           DiskDir		jsr	xParSetWrite
ed15 : a910             		lda	#PC_GET_DIR	;send command
ed17 : 20b0ec           		jsr	xParWriteByte
ed1a : 18               		clc		;assume it works
ed1b : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   44
---------------------------------- xKIM.asm ----------------------------------

                        ;=====================================================
                        ; Read the next directory entry.  On input, X (MSB)
                        ; and Y (LSB) point to a 13 byte area to receive the
                        ; drive data.
                        ;
                        ; Returns C set if end of directory (ie, attempt to
                        ; read and there are none left).  Else, C is clear
                        ; and X/Y point to the null at end of filename.
                        ;
ed1c : 86fb             DiskDirNext	stx	POINTH
ed1e : 84fa             		sty	POINTL
ed20 : 20a2ec           		jsr	xParSetRead	;read results
ed23 : 20dbec           		jsr	xParReadByte	;get response code
ed26 : c983             		cmp	#PR_NAK		;error?
ed28 : f01e             		beq	DDNErr
ed2a : c991             		cmp	#PR_DIR_END	;end?
ed2c : f01a             		beq	DDNErr
                        ;
                        ; This contains a directory entry.
                        ;
ed2e : a000             		ldy	#0
ed30 : 20dbec           DDNloop		jsr	xParReadByte
ed33 : 91fa             		sta	(POINTL),y
ed35 : c900             		cmp	#0	;end?
ed37 : f006             		beq	DDNEnd
ed39 : 20631f           		jsr	INCPT
ed3c : 4c30ed           		jmp	DDNloop
ed3f : 2092ec           DDNEnd		jsr	xParSetWrite
ed42 : a6fb             		ldx	POINTH
ed44 : a4fa             		ldy	POINTL
ed46 : 18               		clc		;not end of files
ed47 : 60               		rts
                        ;
                        ; Error.  Set C and return.  This is not really
                        ; proper, since this implies a simple end of the
                        ; directory rather than an error.
                        ;
ed48 : 2092ec           DDNErr		jsr	xParSetWrite
ed4b : 38               		sec
ed4c : 60               		rts
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   45
---------------------------------- xKIM.asm ----------------------------------

                        ;=====================================================
                        ; This opens a file on the SD for reading.  On entry,
                        ; X (MSB) and Y (LSB) point to a null-terminated
                        ; filename to open.  On return, C is clear if the file
                        ; is open, or C set if an error (usually means the
                        ; file does not exist.
                        ;
                        ; Assumes write mode has been set.  Returns with it se
                        ;
ed4d : a916             DiskOpenRead	lda	#PC_READ_FILE
ed4f :                  DiskOpen
ed4f : 84f8                     sty	INL	;save ptr to filename
ed51 : 86f9             		stx	INH
ed53 : 20b0ec           		jsr	xParWriteByte
ed56 : a0ff             		ldy	#-1
ed58 : c8               DiskOpenLoop	iny
ed59 : b1f8             		lda	(INL),y
ed5b : 20b0ec           		jsr	xParWriteByte
ed5e : b1f8             		lda	(INL),y
ed60 : d0f6             		bne	DiskOpenLoop
ed62 : 20a2ec           		jsr	xParSetRead
ed65 : 20dbec           		jsr	xParReadByte	;get response
ed68 : c982             		cmp	#PR_ACK
ed6a : d005             		bne	DiskOpenErr
ed6c : 2092ec           		jsr	xParSetWrite	;back to write mode
ed6f : 18               		clc
ed70 : 60               		rts
                        ;
                        ; Got an error.
                        ;
ed71 : 20dbec           DiskOpenErr	jsr	xParReadByte	;get error code
ed74 : 2092ec           		jsr	xParSetWrite	;back to write mode
ed77 : 38               		sec
ed78 : 60               		rts
                        ;=====================================================
                        ; This opens a file on the SD for writing.  On entry,
                        ; X (MSB) and Y (LSB) point to a null-terminated
                        ; filename to open.  On return, C is clear if the file
                        ; is open, or C set if an error.
                        ;
                        ; Assumes write mode has been set.  Returns with it se
                        ;
ed79 : a91b             DiskOpenWrite	lda	#PC_WRITE_FILE
ed7b : 4c4fed           		jmp	DiskOpen	;jump into common code
                        ;
                        ;=====================================================
                        ; On entry, A contains the number of bytes to read
                        ; from the file, X (MSB) and Y (LSB) point to the
                        ; buffer where to put the data.  On return, C will
                        ; be set if EOF was reached (and no data read), or
                        ; C will be clear and A contains the number of bytes
                        ; actually read into the buffer.
                        ;
                        ; Modifies A, X and Y.  Also modifies INL and INH
                        ; (00F8 and 00F9).
                        ;
ed7e : 84f8             DiskRead	sty	INL	;save ptr to buffer
ed80 : 86f9             		stx	INH
ed82 : 48               		pha
ed83 : a917             		lda	#PC_READ_BYTES
ed85 : 20b0ec           		jsr	xParWriteByte	;command
ed88 : 68               		pla		;number of bytes to get
AS65 Assembler for R6502 [1.42].                                     Page   46
---------------------------------- xKIM.asm ----------------------------------

ed89 : 20b0ec           		jsr	xParWriteByte
ed8c : 20a2ec           		jsr	xParSetRead	;get ready for response
ed8f : 20dbec           		jsr	xParReadByte	;assume PR_FILE_DATA
ed92 : 20dbec           		jsr	xParReadByte	;length
ed95 : 48               		pha
ed96 : aa               		tax			;count
ed97 : f011             		beq	DiskReadEof	;zero = EOF
ed99 : a000             		ldy	#0	;offset
ed9b : 20dbec           DiskReadLoop	jsr	xParReadByte
ed9e : 91f8             		sta	(INL),y
eda0 : c8               		iny		;next offset
eda1 : ca               		dex
eda2 : d0f7             		bne	DiskReadLoop
eda4 : 2092ec           		jsr	xParSetWrite
eda7 : 68               		pla		;retrieve byte count
eda8 : 18               DiskOk		clc	
eda9 : 60               		rts
edaa : 2092ec           DiskReadEof	jsr	xParSetWrite
edad : 68               		pla
edae : 38               		sec
edaf : 60               		rts
                        ;
                        ;=====================================================
                        ; On entry, A contains the number of bytes to write
                        ; to the file, X (MSB) and Y (LSB) point to the
                        ; buffer where to get the data.  On return, C will
                        ; be set if an error was detected, or C will be clear
                        ; if no error.  Note that if A contains 0 on entry,
                        ; no bytes are written.
                        ;
                        ; Modifies A, X and Y.  Also modifies INL and INH
                        ; (00F8 and 00F9).
                        ;
edb0 : c900             DiskWrite	cmp	#0
edb2 : f0f4             		beq	DiskOk
edb4 : 84f8             		sty	INL	;save ptr to filename
edb6 : 86f9             		stx	INH
edb8 : 48               		pha
edb9 : a91c             		lda	#PC_WRITE_BYTES
edbb : 20b0ec           		jsr	xParWriteByte	;command
edbe : 68               		pla		;number of bytes to write
edbf : 48               		pha		;save again
edc0 : 20b0ec           		jsr	xParWriteByte
edc3 : 68               		pla
edc4 : aa               		tax			;count
edc5 : a000             		ldy	#0	;offset
edc7 : b1f8             DiskWriteLoop	lda	(INL),y	;get next byte
edc9 : 20b0ec           		jsr	xParWriteByte
edcc : c8               		iny		;next offset
edcd : ca               		dex
edce : d0f7             		bne	DiskWriteLoop
edd0 : 20a2ec           		jsr	xParSetRead ;read the status
edd3 : 20dbec           		jsr	xParReadByte
edd6 : c982             		cmp	#PR_ACK
edd8 : f008             		beq	DiskOk1	;all good
edda : 20dbec           		jsr	xParReadByte	;read error code
eddd : 2092ec           		jsr	xParSetWrite 
ede0 : 38               		sec	
ede1 : 60               		rts
                        ;
ede2 : 2092ec           DiskOk1		jsr	xParSetWrite
ede5 : 18               		clc
AS65 Assembler for R6502 [1.42].                                     Page   47
---------------------------------- xKIM.asm ----------------------------------

ede6 : 60               		rts
                        ;
                        ;=====================================================
                        ; Call this to close any open file.  No parameters
                        ; and no return status.
                        ;
ede7 : a915             DiskClose	lda	#PC_DONE
ede9 : 4cb0ec           		jmp	xParWriteByte
                        
                        
                        
                        ;
                        ;=====================================================
                        ; Show current clock
                        ;
                        	if	SHOW_RTC
edec : 2092ec           doShowClock	jsr	xParSetWrite
edef : a907             		lda	#PC_GET_CLOCK
edf1 : 20b0ec           		jsr	xParWriteByte
edf4 : 20a2ec           		jsr	xParSetRead	;prepare to read
                        ;
edf7 : 20dbec           		jsr	xParReadByte
                        ;
                        ; Loop to read the raw data
                        ;
edfa : a200             		ldx	#0
edfc : 8e81df           clockread	stx	saveX
edff : 20dbec           		jsr	xParReadByte
ee02 : ae81df           		ldx	saveX
ee05 : 9d9adf           		sta	month,x
ee08 : e8               		inx
ee09 : e008             		cpx	#clock_end-month
ee0b : d0ef             		bne	clockread
                        ;
                        ; Set back to write mode to finish up; all apps are
                        ; supposed to leave the SD interface in write mode.
                        ;
ee0d : 2092ec           		jsr	xParSetWrite
                        ;
                        ; Now display the data in a user-friendly format.  Eac
                        ; numberic value is in binary, so convert to decimal
                        ; for display.
                        ;
ee10 : 20d1ea           		jsr	putsil
ee13 : 0d0a             		db	CR,LF
ee15 : 446174653a2000   		db	"Date: ",0
                        ;
ee1c : ad9adf           		lda	month
ee1f : 2065ee           		jsr	outdec
ee22 : a92f             		lda	#'/'
ee24 : 20a01e           		jsr	OUTCH
ee27 : ad9bdf           		lda	day
ee2a : 2065ee           		jsr	outdec
                        ;
                        ; Always force the high part of the year to "/20"
                        ;
ee2d : 20d1ea           		jsr	putsil
ee30 : 2f323000         		db	"/20",0
ee34 : ad9ddf           		lda	year_low
ee37 : 2065ee           		jsr	outdec
                        ;
                        ; Space over, then do the time
AS65 Assembler for R6502 [1.42].                                     Page   48
---------------------------------- xKIM.asm ----------------------------------

                        ;
ee3a : 20d1ea           		jsr	putsil
ee3d : 2c2000           		db	", ",0
                        ;
ee40 : ad9edf           		lda	hour
ee43 : 2065ee           		jsr	outdec
ee46 : a93a             		lda	#':'
ee48 : 20a01e           		jsr	OUTCH
ee4b : ad9fdf           		lda	minute
ee4e : 2065ee           		jsr	outdec
ee51 : a93a             		lda	#':'
ee53 : 20a01e           		jsr	OUTCH
ee56 : ada0df           		lda	second
ee59 : 2065ee           		jsr	outdec
                        ;
ee5c : 20d1ea           		jsr	putsil
ee5f : 0d0a00           		db	CR,LF,0
ee62 : 4c60e0           		jmp	extKim	;return to monitor
                        ;
                        ;=====================================================
                        ; Given a binary value in A, display it as two decimal
                        ; digits.  The input can't be greater than 99.  Always
                        ; print a leading zero if less than 10.
                        ;
ee65 : a000             outdec		ldy	#0	;counts 10s
ee67 : c90a             out1		cmp	#10
ee69 : 9007             		bcc	out2	;below 10
ee6b : c8               		iny		;count 10
ee6c : 38               		sec
ee6d : e90a             		sbc	#10
ee6f : 4c67ee           		jmp	out1
                        ;
ee72 : 48               out2		pha		;save ones
ee73 : 98               		tya		;get tens
ee74 : 2078ee           		jsr	out3	;print tens digit
ee77 : 68               		pla		;restore ones
                        ;
ee78 : 0930             out3		ora	#'0'
ee7a : 20a01e           		jsr	OUTCH
ee7d : 60               		rts
                        
                        	endif
                        ;
                        	if	TINY_BASIC
                        		include "mytb.asm"
                        	endif
                        		page
AS65 Assembler for R6502 [1.42].                                     Page   49
---------------------------------- xKIM.asm ----------------------------------

                        		
                        ;
                        ;=====================================================
                        ; Handles the command to save a region of memory to
                        ; an IEC device.
                        ;
ee7e : 4c40e1           lExit111		jmp	extKimLoop
ee81 : 205ceb           saveIEC		jsr	getAddrRange	;get range to dump
ee84 : b0f8             			bcs	lExit111		;abort on error
                        ;
                        ; Get the file id to save to
                        ;		
ee86 : 20d1ea           		jsr	putsil
ee89 : 0d0a             		db	CR,LF
ee8b : 456e7465722066.. 		db	"Enter file ID ($01-$FE):",0
eea4 : 2000eb           		jsr	getHex
eea7 : b0d5             		bcs	lExit111		;abort on error
eea9 : 8df917           		sta	IECFID
                        		
eeac : 2019ef           		jsr savevec
                        		
eeaf : a900             		lda #$00
eeb1 : 8dfa17           		sta NMIL
eeb4 : 8dfc17           		sta RSTL
eeb7 : 8dfe17           		sta IRQL
eeba : a9e0             		lda #$E0
eebc : 8dfb17           		sta NMIH
eebf : 8dfd17           		sta RSTH
eec2 : 8dff17           		sta IRQH
                        		
eec5 : 2048f1           		jsr IECSAV
                        		
eec8 : 204eef           		jsr loadvec
                        		
eecb : 4c40e1           		jmp	extKimLoop
                        ;
                        ;=====================================================
                        ; Handles the command to load a region of memory from
                        ; an IEC device.
                        ;
eece : 4c40e1           lExit1111		jmp	extKimLoop
eed1 :                  loadIEC		
                        ; Get the file id to save to
                        ;		
eed1 : 20d1ea           		jsr	putsil
eed4 : 0d0a             		db	CR,LF
eed6 : 456e7465722066.. 		db	"Enter file ID ($01-$FE):",0
eeef : 2000eb           		jsr	getHex
eef2 : b0da             		bcs	lExit1111		;abort on error
eef4 : 8df917           		sta	IECFID
                        		
eef7 : 2019ef           		jsr savevec
                        		
eefa : a900             		lda #$00
eefc : 8dfa17           		sta NMIL
eeff : 8dfc17           		sta RSTL
ef02 : 8dfe17           		sta IRQL
ef05 : a9e0             		lda #$E0
ef07 : 8dfb17           		sta NMIH
ef0a : 8dfd17           		sta RSTH
ef0d : 8dff17           		sta IRQH
                        		
AS65 Assembler for R6502 [1.42].                                     Page   50
---------------------------------- xKIM.asm ----------------------------------

ef10 : 2000f0           		jsr IECLOD
                        
ef13 : 204eef           		jsr loadvec
                        		
ef16 : 4c40e1           		jmp	extKimLoop
                        
ef19 :                  savevec 
ef19 : 8c82df           		sty saveY
                        		
ef1c : acfa17           		ldy NMIL
ef1f : 8c83df           		sty saveNMIL
ef22 : acfb17           		ldy NMIH
ef25 : 8c84df           		sty saveNMIH
ef28 : acfc17           		ldy RSTL
ef2b : 8c85df           		sty saveRSTL
ef2e : acfd17           		ldy RSTH
ef31 : 8c86df           		sty saveRSTH
ef34 : acfe17           		ldy IRQL
ef37 : 8c87df           		sty saveIRQL
ef3a : acff17           		ldy IRQH
ef3d : 8c88df           		sty saveIRQH
                        		
ef40 : a0ab             		ldy	#VEC_FLAG_1
ef42 : 8c00e0           		sty	VecFlag
ef45 : a0ab             		ldy	#VEC_FLAG_2
ef47 : 8c01e0           		sty	VecFlag+1
                        		
ef4a : ac82df           		ldy saveY
                        		
ef4d : 60               		rts
                        		
ef4e :                  loadvec
ef4e : 8c82df           		sty saveY
ef51 : ac83df           		ldy saveNMIL
ef54 : 8cfa17           		sty NMIL
ef57 : ac84df           		ldy saveNMIH
ef5a : 8cfb17           		sty NMIH
ef5d : ac85df           		ldy saveRSTL
ef60 : 8cfc17           		sty RSTL
ef63 : ac86df           		ldy saveRSTH
ef66 : 8cfd17           		sty RSTH
ef69 : ac87df           		ldy saveIRQL
ef6c : 8cfe17           		sty IRQL
ef6f : ac88df           		ldy saveIRQH
ef72 : 8cff17           		sty IRQH
ef75 : ac82df           		ldy saveY
                        		
ef78 : 60               		rts
                        
                        ;
                        ;=====================================================
                        ; These are the 6502 vectors.  On the Corsham
                        ; Technologies RAM/ROM board the user can select
                        ; whether or not to use these based on a switch
                        ; setting on the board.
                        ;
fffa =                  		org	$fffa
fffa : 1c1c             NMI		dw	NMIT	;in KIM
fffc : 221c             RESET		dw	RST	;in KIM
fffe : 1f1c             IRQ		dw	IRQT	;in KIM
                        ;
                        		end
AS65 Assembler for R6502 [1.42].                                     Page   51
---------------------------------- xKIM.asm ----------------------------------

                        
                        
No errors in pass 2.
Wrote binary from address $e000 through $ffff.
Total size 8192 bytes.
